<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebCodecs H264 + PCM æ’­æ”¾å™¨ï¼ˆå¯ä¿å­˜ï¼‰</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton {
      position: fixed;
      top: 100px;
      left: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #uploadBtn {
      position: fixed;
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
<canvas id="canvas"></canvas>
<button id="saveButton" onclick="downloadStreams()">é€‰æ‹©ç…§ç‰‡</button>
<button id="uploadBtn">é€‰æ‹©ç…§ç‰‡</button>
<input type="file" id="fileInput" accept="image/*" style="display:none" />
<div id="latencyDisplay">â± å»¶æ—¶: -- ms</div>

<script>
  // --- WebSocket è‡ªåŠ¨é‡è¿å’Œå®‰å…¨å‘é€å°è£… ---
  let socket = null;
  let reconnectTimer = null;
  let connect = false;
  let os = "";
  let latency = '--';
  let pingStartTime = 0;
  let pingInterval = null;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=287467d5dc90550e9431a7226f03024d'); //wss://cn2.androidcloudtest.com/scws ws://192.168.190.4:3000
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('âœ… WebSocket å·²è¿æ¥');
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      /*console.log('resend', resend);
      if (resend) {
        console.log('é‡å‘å›¾ç‰‡');
        safeSendPhoto(lastImageData);
        resend = false;
      }*/
      document.getElementById('latencyDisplay').textContent = `âœ… å·²è¿æ¥ | å»¶æ—¶: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        //safeSend(JSON.stringify({ switch_activity: `com.android.settings/.Settings` })); //com.s15af5x.all2/com.yyds.sportnew.StartActivity com.android.settings/.Settings
        //safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //å¼€äº‘ å¾ˆæ…¢ schemeåŠŸèƒ½ok
        //safeSend(JSON.stringify({ scheme: `t06fut://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //çˆ±æ¸¸æˆ schemeåŠŸèƒ½ok
        //safeSend(JSON.stringify({ scheme: `tqnc02://com.s15af5x.fao2f4o5?data=bobCloud&name=shawn1&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //ä¹é±¼ å¾ˆæ…¢ schemeåŠŸèƒ½ok
        //safeSend(JSON.stringify({ scheme: `tg7ooa://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //åä½“ä¼š å¾ˆæ…¢ schemeåŠŸèƒ½ok
        safeSend(JSON.stringify({ scheme: `tcph0g://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //ç±³å…° å¾ˆæ…¢ schemeåŠŸèƒ½ok
        //safeSend(JSON.stringify({ scheme: `tap6xh://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //ä¹æ¸¸ å¾ˆæ…¢ schemeåŠŸèƒ½ok
        //safeSend(JSON.stringify({ scheme: ` od://com.od.games?data=odCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //od é—ªé€€
        //safeSend(JSON.stringify({ scheme: ` xk://com.xk.games?data=xkCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //æ˜Ÿç©º é—ªé€€
        //safeSend(JSON.stringify({ scheme: `tc0hdu://com.bob.live?data=bobCloud&name=shawn1&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //MK å¾ˆæ…¢ ä¸å¯¹
        //safeSend(JSON.stringify({ scheme: `tqnc02://com.s15af5x.fao2f4o5?data=bobCloud&name=final006&password=7Kxg5sfoqHX4GT6CLjFK1g%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }
      if (pingInterval) {
        clearInterval(pingInterval);
      }
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      //console.warn(`[${new Date().toLocaleString()}] 222`);
      /*if (Date.now() - lastSendTime < 100) {
        resend = true;
        console.log(`[${new Date().toLocaleString()}] âŒ WebSocket å·²æ–­å¼€ï¼Œ2ç§’åå°è¯•é‡è¿, 100mså†…ï¼Œé‡å‘ç…§ç‰‡`);
      } else {
        console.warn(`[${new Date().toLocaleString()}] âŒ WebSocket å·²æ–­å¼€ï¼Œ2ç§’åå°è¯•é‡è¿`);
      }*/
      console.warn(`[${new Date().toLocaleString()}] âŒ WebSocket å·²æ–­å¼€ï¼Œ2ç§’åå°è¯•é‡è¿`);
      document.getElementById('latencyDisplay').textContent = 'âŒ è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
      connect = false;
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
      if (!reconnectTimer) {
        reconnectTimer = setTimeout(() => {
          createSocket();
        }, 2000);
      }
    };

    socket.onerror = (e) => {
      console.warn('WebSocket é”™è¯¯:', e);
    };

    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(data);
    } else {
      console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend è¢«å¿½ç•¥:', data);
    }
  }

  // --- Canvas å’Œ WebCodecs è§†é¢‘è§£ç ç›¸å…³ ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let lastFpsTime = performance.now();
  let currentFps = 0;

  let videoDecoder = new VideoDecoder({
    output: frame => {
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
      frame.close();
      decodedFrameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        currentFps = decodedFrameCount;
        decodedFrameCount = 0;
        lastFpsTime = now;
        document.getElementById('latencyDisplay').textContent = `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps}`;
      }
    },
    error: e => console.error('VideoDecoder error:', e),
  });

  videoDecoder.configure({
    codec: 'avc1.4d401f',
    codedWidth: 720,
    codedHeight: 1280,
    optimizeForLatency: true,
    hardwareAcceleration: "prefer-hardware",
  });

  // --- éŸ³é¢‘æ’­æ”¾ ---
  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000;
  const channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        const sample = int16Data[i * channelCount + ch];
        channelData[i] = sample / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) {
      nextAudioTime = now;
    }
    if (nextAudioTime - now > MAX_DELAY) {
      nextAudioTime = now;
    }

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => {
      source.disconnect();
    };
  }

  // --- ç”»å¸ƒç¼©æ”¾é€‚é… ---
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let displayWidth = windowWidth;
    let displayHeight = windowWidth / aspectRatio;

    if (displayHeight > windowHeight) {
      displayHeight = windowHeight;
      displayWidth = windowHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // --- è§¦æ‘¸å’Œé¼ æ ‡äº‹ä»¶ ---
  let isDown = false;
  let throttleTimer = null;
  let showPhoto = false;
  let photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function sendDown(x, y) {
    safeSend(JSON.stringify({ start: `${x},${y}` }));
  }

  function sendMove(x, y) {
    safeSend(JSON.stringify({ swipe: `${x},${y}` }));
  }

  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));

    if (photoRegion) {
      const { left, top, right, bottom } = photoRegion;
      const inside = x >= left && x <= right && y >= top && y <= bottom;
      if (inside) {
        console.log('âœ… ç‚¹å‡»åœ¨ç…§ç‰‡åŒºåŸŸå†…:', x, y);
        showPhoto = false;
        photoRegion = null;
        uploadBtn.click();
      } else {
        console.log('âŒ ç‚¹å‡»åœ¨åŒºåŸŸå¤–:', x, y);
      }
    }
  }

  canvas.addEventListener('mousedown', e => {
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendDown(x, y);
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    e.preventDefault();
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('mouseup', e => {
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendUp(x, y);
  });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 0) return;
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendDown(x, y);
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    if (e.changedTouches.length === 0) return;
    const touch = e.changedTouches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendUp(x, y);
  }, { passive: false });

  // --- éŸ³è§†é¢‘ç¼“å­˜å’Œè§£ç  ---
  const frameQueue = [];
  const MAX_FRAME_QUEUE = 10;
  let decoding = false;
  let isStart = false;
  let lastVideoTimestamp = 0;
  const frameDurationUs = 1000000 / 60;

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payload = frameQueue.shift();
    const isKey = isIDR(payload);

    if (!isKey && !isStart) return;

    decoding = true;
    try {
      if (isKey) {
        isStart = true;
        lastVideoTimestamp = performance.now() * 1000;
      } else {
        lastVideoTimestamp += frameDurationUs;
      }

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: lastVideoTimestamp,
        data: payload
      });

      videoDecoder.decode(chunk);
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
    } finally {
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try {
      if (videoDecoder.state !== 'closed') videoDecoder.close();
    } catch (e) {
      console.warn('å…³é—­ decoder å¤±è´¥:', e);
    }

    try {
      videoDecoder = new VideoDecoder({
        output: frame => {
          ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
          frame.close();
          decodedFrameCount++;
          const now = performance.now();
          if (now - lastFpsTime >= 1000) {
            currentFps = decodedFrameCount;
            decodedFrameCount = 0;
            lastFpsTime = now;
            document.getElementById('latencyDisplay').textContent = `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps}`;
          }
        },
        error: e => console.error('VideoDecoder error:', e),
      });

      videoDecoder.configure({
        codec: 'avc1.4d401f',
        optimizeForLatency: true,
        hardwareAcceleration: "prefer-hardware",
        codedWidth: 720,
        codedHeight: 1280,
      });

      isStart = false;
      console.log('âœ… Decoder é‡å»ºæˆåŠŸï¼Œç­‰å¾…å…³é”®å¸§');
    } catch (e) {
      console.error('âŒ Decoderæ¢å¤å¤±è´¥:', e);
    }
  }

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (
        payload[i] === 0x00 &&
        payload[i+1] === 0x00 &&
        payload[i+2] === 0x00 &&
        payload[i+3] === 0x01
      ) {
        const nalType = payload[i+4] & 0x1F;
        if (nalType === 5) { // IDRå¸§
          return true;
        }
      }
    }
    return false;
  }

  // --- WebSocket æ¶ˆæ¯å¤„ç† ---
  function onMessageHandler(event) {
    const data = event.data;
    //console.log("æ”¶åˆ°æ¶ˆæ¯:", event.data);
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd === 'pong') {
          const pingEndTime = performance.now();
          latency = Math.round(pingEndTime - pingStartTime);
          document.getElementById('latencyDisplay').textContent = `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps}`;
        }
      } catch (e) {
        console.warn('JSON è§£æå¤±è´¥:', e);
      }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    if (type === 0x01) { // è§†é¢‘
      if (frameQueue.length >= MAX_FRAME_QUEUE) {
        const index = frameQueue.findIndex(buf => !isIDR(buf));
        if (index !== -1) {
          frameQueue.splice(index, 1);
        } else {
          frameQueue.shift();
        }
        console.warn('âš ï¸ ä¸¢å¸§ä»¥æ§åˆ¶å»¶è¿Ÿ');
      }
      frameQueue.push(payload);
      decodeNextFrame();
    } else if (type === 0x02) { // éŸ³é¢‘
      try {
        playPCM(payload);
      } catch (err) {
        console.error('PCM æ’­æ”¾å‡ºé”™:', err);
      }
    } else if (type === 0x03) { // é”®ç›˜
      const show = payload[0];
      console.log("é”®ç›˜æŒ‡ä»¤ show =", show);
      if (os === "android") {
        if (show === 1) {
          //document.getElementById('fakeInput').focus();
        } else {
          //document.getElementById('fakeInput').blur();
        }
      }
    } else if (type === 0x04) { // ç…§ç‰‡åŒºåŸŸ
      if (payload.length >= 8) {
        const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        const left = view.getInt16(0);
        const top = view.getInt16(2);
        const right = view.getInt16(4);
        const bottom = view.getInt16(6);
        console.log("ğŸ“¸ ç…§ç‰‡åŒºåŸŸåæ ‡:", left, top, right, bottom);
        photoRegion = { left, top, right, bottom };
        showPhoto = true;
      } else {
        photoRegion = null;
        console.warn('âš ï¸ æ”¶åˆ°0x04æ•°æ®é•¿åº¦ä¸è¶³');
      }
    } else if (type === 0x05) { // ready
      console.log("ready")
      if (payload[0] === 1) {
        console.log("payload[0]:", payload[0])
      }
      
    }
  }

  // --- å‘é€ ping æµ‹å»¶æ—¶ ---
  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // --- é€‰æ‹©ç…§ç‰‡ä¸Šä¼ ç›¸å…³ ---
  const fileInput = document.getElementById('fileInput');
  const saveButton = document.getElementById('saveButton');
  const uploadBtn = document.getElementById('uploadBtn');
  let lastImageData = null; // ç¼“å­˜å›¾ç‰‡æ•°æ®
  //let lastSendTime = 0;
  //let resend = false;

  uploadBtn.onclick = () => {
    fileInput.click();
  };

  fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      const uint8Arr = new Uint8Array(arrayBuffer);
      console.log('ğŸ“· é€‰ä¸­å›¾ç‰‡ï¼Œå¤§å°:', uint8Arr.length);
      //lastImageData = uint8Arr; // ç¼“å­˜ä¸‹æ¥
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    // è¿™é‡Œå¦‚æœä½ æœ‰ç¼“å­˜è§†é¢‘éŸ³é¢‘æ•°æ®ï¼Œå¯ä»¥æ‰“åŒ…ä¸‹è½½
    document.getElementById("saveButton").style.display = "none";
  }

  const CHUNK_SIZE = 64 * 1024; // 64KB
  function safeSendPhoto(data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend photo è¢«å¿½ç•¥');
      return;
    }

    console.warn(`[${new Date().toLocaleString()}] ğŸ“¤ å¼€å§‹å‘é€å›¾ç‰‡ï¼Œå¤§å°: ${data.length} bytes`);

    const totalChunks = Math.ceil(data.length / CHUNK_SIZE);
    const uid = Date.now(); // æ¯å¼ å›¾ä¸€ä¸ªå”¯ä¸€ ID

    for (let i = 0; i < totalChunks; i++) {
      const chunk = data.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);

      const message = {
        type: 'photo_chunk',
        uid,              // å›¾åƒå”¯ä¸€æ ‡è¯†
        index: i,         // å½“å‰å—åºå·
        total: totalChunks, // æ€»å—æ•°
        data: Array.from(chunk), // è½¬æˆå¯åºåˆ—åŒ–æ ¼å¼
      };

      socket.send(JSON.stringify(message));
    }

    lastSendTime = Date.now();
    console.warn(`[${new Date().toLocaleString()}] âœ… å›¾ç‰‡æ‹†åŒ…å‘é€å®Œæˆï¼Œå…± ${totalChunks} å—`);
  }

  // --- é¡µé¢åˆå§‹åŒ– ---
  createSocket();

</script>
</body>
</html>
