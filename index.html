<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>WebCodecs H264 + PCM æ’­æ”¾å™¨ï¼ˆiOS 16.7 ä¿®æ­£ç‰ˆï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      left: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #saveButton { top: 100px; }
    #uploadBtn { top: 150px; }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</head>
<body>
<canvas id="canvas"></canvas>
<button id="saveButton" onclick="downloadStreams()">é€‰æ‹©ç…§ç‰‡</button>
<button id="uploadBtn">é€‰æ‹©ç…§ç‰‡</button>
<input type="file" id="fileInput" accept="image/*" style="display:none" />
<div id="latencyDisplay">â± å»¶æ—¶: -- ms</div>

<script>
  // ============================
  // WebSocket è‡ªåŠ¨é‡è¿ + å®‰å…¨å‘é€
  // ============================
  let socket = null;
  let reconnectTimer = null;
  let connect = false;
  let os = "";
  let latency = '--';
  let pingStartTime = 0;
  let pingInterval = null;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=287467d5dc90550e9431a7226f03024d');
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('âœ… WebSocket å·²è¿æ¥');
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      document.getElementById('latencyDisplay').textContent = `âœ… å·²è¿æ¥ | å»¶æ—¶: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tcph0g://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }
      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] âŒ WebSocket å·²æ–­å¼€ï¼Œ2ç§’åå°è¯•é‡è¿`);
      document.getElementById('latencyDisplay').textContent = 'âŒ è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) {
        reconnectTimer = setTimeout(() => { createSocket(); }, 2000);
      }
    };

    socket.onerror = (e) => {
      console.warn('WebSocket é”™è¯¯:', e);
    };

    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(data);
    } else {
      console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend è¢«å¿½ç•¥:', data);
    }
  }

  // ============================
  // ç”»å¸ƒ & æ˜¾ç¤º
  // ============================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let lastFpsTime = performance.now();
  let currentFps = 0;

  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let displayWidth = windowWidth;
    let displayHeight = windowWidth / aspectRatio;

    if (displayHeight > windowHeight) {
      displayHeight = windowHeight;
      displayWidth = windowHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ============================
  // WebCodecs è§†é¢‘è§£ç ï¼ˆiOS 16.7 å…¼å®¹ï¼‰
  // å…³é”®æ”¹åŠ¨ï¼š
  // 1) ä¸¥æ ¼è‡ªå¢æ—¶é—´æˆ³ï¼ˆusï¼‰ï¼Œä»0å¼€å§‹
  // 2) output é‡Œä½¿ç”¨ createImageBitmap å† drawImage
  // 3) å»æ‰ hardwareAcceleration é€‰é¡¹
  // 4) é¦–é€‰ Main Profileï¼Œå†å›è½åˆ° Baseline
  // ============================

  let videoDecoder = null;

  async function configureDecoder() {
    if (videoDecoder && videoDecoder.state !== 'closed') {
      try { videoDecoder.close(); } catch (e) {}
    }

    const output = async (frame) => {
      try {
        // iOS 16.x: ç›´æ¥ drawImage(VideoFrame) å¶å‘é»‘å±
        const bitmap = await createImageBitmap(frame);
        ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        bitmap.close();
      } finally {
        frame.close();
      }
      decodedFrameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        currentFps = decodedFrameCount;
        decodedFrameCount = 0;
        lastFpsTime = now;
        document.getElementById('latencyDisplay').textContent = `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps}`;
      }
    };

    const error = (e) => console.error('VideoDecoder error:', e);

    videoDecoder = new VideoDecoder({ output, error });

    const candidates = [
      { codec: 'avc1.4d401f', codedWidth: 720, codedHeight: 1280, optimizeForLatency: true }, // Main@L3.1
      { codec: 'avc1.42E01E', codedWidth: 720, codedHeight: 1280, optimizeForLatency: true }, // Baseline@L3.0
    ];

    for (const cfg of candidates) {
      try {
        // Safari 16.7 çš„ isConfigSupported å¯èƒ½è¿”å›ä¹è§‚ç»“æœï¼Œè¿™é‡Œç›´æ¥å°è¯• configureï¼Œå¤±è´¥å†å›é€€
        await videoDecoder.configure(cfg);
        console.log('âœ… ä½¿ç”¨è§£ç é…ç½®:', cfg.codec);
        return;
      } catch (e) {
        console.warn('âš ï¸ é…ç½®å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª:', cfg.codec, e);
      }
    }

    console.error('âŒ æ²¡æœ‰å¯ç”¨çš„ H.264 è§£ç é…ç½®');
  }

  // ä¸¥æ ¼è‡ªå¢çš„æ—¶é—´æˆ³ï¼ˆå¾®ç§’ï¼‰
  const frameQueue = [];
  const MAX_FRAME_QUEUE = 10;
  let decoding = false;
  let isStart = false;
  let lastVideoTimestamp = 0;
  const frameDurationUs = Math.round(1000000 / 60); // 60fps çº¦ 16667us
  let haveSps = false, havePps = false;

  function decodeNextFrame() {
    if (decoding) return;
    if (!videoDecoder || videoDecoder.state === 'closed') return;
    if (frameQueue.length === 0) return;
    if (videoDecoder.decodeQueueSize > 3) return;

    const payload = frameQueue.shift();

    const info = scanNal(payload);
    if (info.hasSps) haveSps = true;
    if (info.hasPps) havePps = true;
    const isKey = info.hasIdr;

    // å¿…é¡»ä» IDR å¼€å§‹ï¼Œä¸”è¦åœ¨ IDR å‰æ‹¿åˆ° SPS/PPS
    if (!isStart) {
      if (!(isKey && haveSps && havePps)) {
        // æ²¡åˆ°å¯ç”¨èµ·ç‚¹ï¼Œç»§ç»­ç­‰
        return;
      }
      isStart = true;
      lastVideoTimestamp = 0;
    } else {
      lastVideoTimestamp += frameDurationUs;
    }

    const chunk = new EncodedVideoChunk({
      type: isKey ? 'key' : 'delta',
      timestamp: lastVideoTimestamp,
      data: payload,
    });

    try {
      decoding = true;
      videoDecoder.decode(chunk);
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
    } finally {
      decoding = false;
      Promise.resolve().then(decodeNextFrame);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder && videoDecoder.state !== 'closed') videoDecoder.close(); } catch (e) { console.warn('å…³é—­ decoder å¤±è´¥:', e); }
    videoDecoder = null;
    isStart = false;
    haveSps = havePps = false;
    configureDecoder().then(() => {
      console.log('âœ… Decoder é‡å»ºæˆåŠŸï¼Œç­‰å¾…å…³é”®å¸§+SPS/PPS');
    }).catch(e => console.error('âŒ Decoder æ¢å¤å¤±è´¥:', e));
  }

  // æ‰«æ Annex-B NALï¼šæ”¯æŒ 00 00 00 01 å’Œ 00 00 01 èµ·å§‹ç 
  function scanNal(payload) {
    let hasIdr = false, hasSps_ = false, hasPps_ = false;
    for (let i = 0; i < payload.length - 4; i++) {
      // 00 00 01
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x01) {
        const nalType = payload[i+3] & 0x1F;
        if (nalType === 5) hasIdr = true;      // IDR
        if (nalType === 7) hasSps_ = true;     // SPS
        if (nalType === 8) hasPps_ = true;     // PPS
      }
      // 00 00 00 01
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        const nalType = payload[i+4] & 0x1F;
        if (nalType === 5) hasIdr = true;
        if (nalType === 7) hasSps_ = true;
        if (nalType === 8) hasPps_ = true;
      }
    }
    return { hasIdr, hasSps: hasSps_, hasPps: hasPps_ };
  }

  // ============================
  // éŸ³é¢‘ï¼ˆPCM 16bit LE, 8kHz, monoï¼‰
  // ============================
  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000;
  const channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        const sample = int16Data[i * channelCount + ch];
        channelData[i] = sample / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => { source.disconnect(); };
  }

  // ============================
  // è§¦æ‘¸/é¼ æ ‡äº‹ä»¶é€ä¼ 
  // ============================
  let isDown = false;
  let throttleTimer = null;
  let showPhoto = false;
  let photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { safeSend(JSON.stringify({ swipe: `${x},${y}` })); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const { left, top, right, bottom } = photoRegion;
      const inside = x >= left && x <= right && y >= top && y <= bottom;
      if (inside) {
        console.log('âœ… ç‚¹å‡»åœ¨ç…§ç‰‡åŒºåŸŸå†…:', x, y);
        showPhoto = false;
        photoRegion = null;
        uploadBtn.click();
      } else {
        console.log('âŒ ç‚¹å‡»åœ¨åŒºåŸŸå¤–:', x, y);
      }
    }
  }

  canvas.addEventListener('mousedown', e => {
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendDown(x, y);
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    e.preventDefault();
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('mouseup', e => {
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendUp(x, y);
  });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 0) return;
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendDown(x, y);
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    if (e.changedTouches.length === 0) return;
    const touch = e.changedTouches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendUp(x, y);
  }, { passive: false });

  // ============================
  // WebSocket æ¶ˆæ¯å¤„ç†
  // ============================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd === 'pong') {
          const pingEndTime = performance.now();
          latency = Math.round(pingEndTime - pingStartTime);
          document.getElementById('latencyDisplay').textContent = `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps}`;
        }
      } catch (e) {
        console.warn('JSON è§£æå¤±è´¥:', e);
      }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    if (type === 0x01) { // è§†é¢‘
      if (frameQueue.length >= MAX_FRAME_QUEUE) {
        const index = frameQueue.findIndex(buf => !scanNal(buf).hasIdr);
        if (index !== -1) {
          frameQueue.splice(index, 1);
        } else {
          frameQueue.shift();
        }
        console.warn('âš ï¸ ä¸¢å¸§ä»¥æ§åˆ¶å»¶è¿Ÿ');
      }
      frameQueue.push(payload);
      decodeNextFrame();
    } else if (type === 0x02) { // éŸ³é¢‘
      try { playPCM(payload); } catch (err) { console.error('PCM æ’­æ”¾å‡ºé”™:', err); }
    } else if (type === 0x03) { // é”®ç›˜
      const show = payload[0];
      console.log("é”®ç›˜æŒ‡ä»¤ show =", show);
    } else if (type === 0x04) { // ç…§ç‰‡åŒºåŸŸ
      if (payload.length >= 8) {
        const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        const left = view.getInt16(0);
        const top = view.getInt16(2);
        const right = view.getInt16(4);
        const bottom = view.getInt16(6);
        console.log("ğŸ“¸ ç…§ç‰‡åŒºåŸŸåæ ‡:", left, top, right, bottom);
        photoRegion = { left, top, right, bottom };
        showPhoto = true;
      } else {
        photoRegion = null;
        console.warn('âš ï¸ æ”¶åˆ°0x04æ•°æ®é•¿åº¦ä¸è¶³');
      }
    } else if (type === 0x05) { // ready
      console.log("ready", payload[0]);
    }
  }

  // ============================
  // Ping for latency
  // ============================
  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // ============================
  // é€‰æ‹©ç…§ç‰‡ä¸Šä¼ ï¼ˆåˆ†ç‰‡ï¼‰
  // ============================
  const fileInput = document.getElementById('fileInput');
  const saveButton = document.getElementById('saveButton');
  const uploadBtn = document.getElementById('uploadBtn');

  uploadBtn.onclick = () => { fileInput.click(); };

  fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      const uint8Arr = new Uint8Array(arrayBuffer);
      console.log('ğŸ“· é€‰ä¸­å›¾ç‰‡ï¼Œå¤§å°:', uint8Arr.length);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    document.getElementById("saveButton").style.display = "none";
  }

  const CHUNK_SIZE = 64 * 1024; // 64KB
  function safeSendPhoto(data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend photo è¢«å¿½ç•¥');
      return;
    }

    console.warn(`[${new Date().toLocaleString()}] ğŸ“¤ å¼€å§‹å‘é€å›¾ç‰‡ï¼Œå¤§å°: ${data.length} bytes`);

    const totalChunks = Math.ceil(data.length / CHUNK_SIZE);
    const uid = Date.now();

    for (let i = 0; i < totalChunks; i++) {
      const chunk = data.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
      const message = {
        type: 'photo_chunk',
        uid,
        index: i,
        total: totalChunks,
        data: Array.from(chunk),
      };
      socket.send(JSON.stringify(message));
    }

    console.warn(`[${new Date().toLocaleString()}] âœ… å›¾ç‰‡æ‹†åŒ…å‘é€å®Œæˆï¼Œå…± ${totalChunks} å—`);
  }

  // ============================
  // é¡µé¢åˆå§‹åŒ–
  // ============================
  (async function init() {
    await configureDecoder();
    createSocket();
  })();

</script>
</body>
</html>
