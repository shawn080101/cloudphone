<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebCodecs H264 + PCM Êí≠ÊîæÂô®ÔºàÂèØ‰øùÂ≠òÔºâ</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #saveButton { top: 100px; left: 10px; }
    #uploadBtn {
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
      display: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
  <canvas id="canvas"></canvas>
  <button id="saveButton" onclick="downloadStreams()">ÈÄâÊã©ÁÖßÁâá</button>
  <button id="uploadBtn">ÈÄâÊã©ÁÖßÁâá</button>
  <input type="file" id="fileInput" accept="image/*" style="display:none" />
  <div id="latencyDisplay">Âª∂Êó∂: -- ms | Ëß£Á†Å: -- ms</div>

  <script>
  // =================== WebSocket Ëá™Âä®ÈáçËøû‰∏éÂèëÈÄÅ ===================
  let socket = null, reconnectTimer = null, connect = false, os = "";
  let latency = '--', pingStartTime = 0, pingInterval = null;
  const token = "770e53e8558903e7efe07501a4c70295";
  const urls = "wss://cn2.androidcloudtest.com";
  const turnUrls = "turn:cnt.androidcloudtest.com:3478"; //turn:cnt.cloudphonews.com:3479 turn:cnt.androidcloudtest.com:3478

  // === Êñ∞Â¢û: ÊéâÂ∏ßÁªüËÆ°ÂèòÈáè ===
  let expectedFrames = 0, decodedFrames = 0, droppedFrames = 0;

  function createSocket() {
    socket = new WebSocket(`${urls}/?token=${token}`); //wss://cn2.androidcloudtest.com ws://192.168.190.4:3000 wss://cloudphonews.com 
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('‚úÖ WebSocket Â∑≤ËøûÊé•');
      if (reconnectTimer) clearTimeout(reconnectTimer);
      document.getElementById('latencyDisplay').textContent = `‚úÖ Â∑≤ËøûÊé• | Âª∂Êó∂: -- ms | Ëß£Á†Å: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        //safeSend(JSON.stringify({ scheme: `tap6xh://com.bob.games?data=bobCloud` }));
        //safeSend(JSON.stringify({ scheme: `null` }));
        //safeSend(JSON.stringify({ scheme: `aa` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ codec: `h264` }));
        //safeSend(JSON.stringify({ webrtc: `false` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] ‚ùå WebSocket Â∑≤Êñ≠ÂºÄÔºå2ÁßíÂêéÂ∞ùËØïÈáçËøû`);
      document.getElementById('latencyDisplay').textContent = '‚ùå ËøûÊé•Êñ≠ÂºÄÔºåÊ≠£Âú®ÈáçËøû...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) reconnectTimer = setTimeout(createSocket, 2000);
    };

    socket.onerror = e => console.warn('WebSocket ÈîôËØØ:', e);
    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) socket.send(data);
    else console.warn('‚ö†Ô∏è WebSocket Êú™ËøûÊé•Ôºåsend Ë¢´ÂøΩÁï•:', data);
  }

  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // =================== Canvas & WebCodecs ËßÜÈ¢ëËß£Á†Å ===================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let videoDecoder = null, frameQueue = [], MAX_FRAME_QUEUE = 10, decoding = false;
  let isStart = false, lastVideoPTS = 0, startTime = 0;

  // === Êñ∞Â¢û: ‰øùÂ≠òÊØè‰∏™PTSÁöÑÊé•Êî∂Êó∂Èó¥ ===
  const recvTimeMap = new Map();
  let lastDecodeCost = '--';

  function initDecoder() {
    if (typeof VideoDecoder === 'undefined' || !('isConfigSupported' in VideoDecoder)) {
      console.error('‚ùå ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅ WebCodecs VideoDecoder');
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('WebCodecs ‰∏çÂèóÊîØÊåÅ', canvas.width / 2, canvas.height / 2);
      initWebRTCTrack();
      return;
    }

    videoDecoder = new VideoDecoder({
      output: frame => {
        const pts = frame.timestamp;
        const endTime = performance.now();
        if (recvTimeMap.has(pts)) {
          const cost = endTime - recvTimeMap.get(pts);
          lastDecodeCost = cost.toFixed(0); // ‰øùÂ≠òËÄóÊó∂(ms)
          recvTimeMap.delete(pts);
        }

        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
        frame.close();
        decodedFrames++;
      },
      error: e => console.error('VideoDecoder error:', e)
    });

    videoDecoder.configure({
      codec: 'avc1.42E01E',
      codedWidth: 720,
      codedHeight: 1280,
      optimizeForLatency: true,
      hardwareAcceleration: "prefer-hardware",
    });

    isStart = false;
    createSocket();
  }
  //initDecoder();
  initWebRTCTrack();

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        if ((payload[i+4] & 0x1F) === 5) return true;
      }
    }
    return false;
  }

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payloadWithPTS = frameQueue.shift();
    expectedFrames++;

    const ptsView = new DataView(payloadWithPTS.buffer, payloadWithPTS.byteOffset, 8);
    const ptsUs = Number(ptsView.getBigUint64(0));
    const nalu = payloadWithPTS.slice(8);
    const isKey = isIDR(nalu);
    console.log('isKey:', isKey)  

    if (!isKey && !isStart) return;

    decoding = true;

    try {
      if (isKey && !isStart) {
        isStart = true;
        lastVideoPTS = ptsUs / 1000;
        startTime = performance.now();
      }

      const targetTime = startTime + (ptsUs / 1000 - lastVideoPTS);
      let delay = targetTime - performance.now();

      if (delay < -2000) delay = 0; // Âª∂ËøüË∂ÖËøá2s ‚Üí Á´ãÂç≥Ëß£Á†Å

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: ptsUs,
        data: nalu
      });

      recvTimeMap.set(ptsUs, performance.now());

      if (delay > 0) {
        setTimeout(() => {
          videoDecoder.decode(chunk);
          decoding = false;
          setTimeout(decodeNextFrame, 0);
        }, delay);
      } else {
        videoDecoder.decode(chunk);
        decoding = false;
        setTimeout(decodeNextFrame, 0);
      }
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder.state !== 'closed') videoDecoder.close(); } catch(e){console.warn(e);}
    initDecoder();
    console.log('‚úÖ Decoder ÈáçÂª∫ÊàêÂäüÔºåÁ≠âÂæÖÂÖ≥ÈîÆÂ∏ß');
  }

  // =================== Èü≥È¢ëÊí≠Êîæ ===================
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000, channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        channelData[i] = int16Data[i * channelCount + ch] / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => source.disconnect();
  }

  // =================== Canvas Áº©ÊîæÈÄÇÈÖç ===================
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    let displayWidth = window.innerWidth;
    let displayHeight = displayWidth / aspectRatio;

    if (displayHeight > window.innerHeight) {
      displayHeight = window.innerHeight;
      displayWidth = displayHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // =================== Èº†Ê†á & Ëß¶Êë∏‰∫ã‰ª∂ ===================
  let isDown = false, moveQueue = [], showPhoto = false, photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (clientX - rect.left) * (canvas.width / rect.width),
      y: (clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { moveQueue.push({x,y}); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const inside = x >= photoRegion.left && x <= photoRegion.right && y >= photoRegion.top && y <= photoRegion.bottom;
      if (inside) { showPhoto = false; photoRegion = null; uploadBtn.click(); }
    }
  }

  function flushMoveQueue() {
    if (moveQueue.length > 0) {
      const last = moveQueue[moveQueue.length - 1];
      safeSend(JSON.stringify({ swipe: `${last.x},${last.y}` }));
      moveQueue = [];
    }
    requestAnimationFrame(flushMoveQueue);
  }
  requestAnimationFrame(flushMoveQueue);

  canvas.addEventListener('mousedown', e => { isDown=true; const c=getCanvasCoords(e.clientX,e.clientY); sendDown(c.x,c.y); });
  canvas.addEventListener('mousemove', e => { if(!isDown) return; const c=getCanvasCoords(e.clientX,e.clientY); sendMove(c.x,c.y); });
  canvas.addEventListener('mouseup', e => { if(!isDown) return; isDown=false; const c=getCanvasCoords(e.clientX,e.clientY); sendUp(c.x,c.y); });

  canvas.addEventListener('touchstart', e => { e.preventDefault(); if(e.touches.length===0) return; isDown=true; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendDown(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!isDown) return; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendMove(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchend', e => { e.preventDefault(); if(!isDown) return; isDown=false; if(e.changedTouches.length===0) return; const t=getCanvasCoords(e.changedTouches[0].clientX,e.changedTouches[0].clientY); sendUp(t.x,t.y); }, {passive:false});

  // =================== WebSocket Ê∂àÊÅØÂ§ÑÁêÜ ===================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd==='pong') { 
          latency = Math.round(performance.now()-pingStartTime); 
        }
        // ÂèØ‰ª•Ê†πÊçÆ msg.error ÂÅöÂ§ÑÁêÜ
        if (msg.error) {
          console.error('ÊúçÂä°Á´ØÈîôËØØ:', msg.error);
        }
      } catch(e){ console.warn('JSON Ëß£ÊûêÂ§±Ë¥•:', e); }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x01:
        if(frameQueue.length>=MAX_FRAME_QUEUE){ 
          const idx=frameQueue.findIndex(buf=>!isIDR(buf));
          if (idx!==-1) {
            frameQueue.splice(idx,1);
            droppedFrames++;
          } else {
            frameQueue.shift();
            droppedFrames++;
          }
        }
        frameQueue.push(payload);
        decodeNextFrame();
        break;
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("ÈîÆÁõòÊåá‰ª§ show =",payload[0]); break;
      case 0x04: 
        if(payload.length>=8){
          const view=new DataView(payload.buffer,payload.byteOffset,payload.byteLength);
          photoRegion={ left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto=true;
        } else { photoRegion=null; }
        break;
      case 0x05: console.log("ready", payload[0]); break;
    }
  }

  // =================== ÂõæÁâá‰∏ä‰º† ===================
  const fileInput=document.getElementById('fileInput');
  const saveButton=document.getElementById('saveButton');
  const uploadBtn=document.getElementById('uploadBtn');

  uploadBtn.onclick=()=>fileInput.click();

  fileInput.onchange=()=>{
    const file=fileInput.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      const uint8Arr=new Uint8Array(reader.result);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    safeSend(JSON.stringify({ bit_rate: `600000` }));
  }

  const CHUNK_SIZE=64*1024;
  function safeSendPhoto(data){
    if(!socket || socket.readyState!==WebSocket.OPEN) return;
    const totalChunks=Math.ceil(data.length/CHUNK_SIZE);
    const uid=Date.now();

    for(let i=0;i<totalChunks;i++){
      const chunk=data.slice(i*CHUNK_SIZE,(i+1)*CHUNK_SIZE);
      const message={ type:'photo_chunk', uid, index:i, total:totalChunks, data:Array.from(chunk) };
      socket.send(JSON.stringify(message));
    }
  }

  // =================== Áªü‰∏ÄÊÄßËÉΩÁõëÊéß ===================
  function monitorPerformance() {
    const totalQueueBytes = frameQueue.reduce((sum, buf) => sum + buf.byteLength, 0);
    const dropRate = expectedFrames > 0 ? (droppedFrames / expectedFrames) * 100 : 0;
    const decodeTime = parseFloat(lastDecodeCost) || 0;
    const currentLatency = latency !== '--' ? latency : 0;

    if (socket && socket.readyState === WebSocket.OPEN) {
      safeSend(JSON.stringify({
        cmd: 'performance',
        latencyPlusDecode: currentLatency + decodeTime, // Âª∂Êó∂+Ëß£Á†Å
        dropRate: dropRate.toFixed(0),
        queueBytes: totalQueueBytes
      }));
    }

    document.getElementById('latencyDisplay').textContent =
      `Âª∂Êó∂+Ëß£Á†Å: ${currentLatency + decodeTime} ms | ÊéâÂ∏ßÁéá: ${dropRate.toFixed(1)}% | ÈòüÂàó: ${(totalQueueBytes/1024).toFixed(0)} KB`;

    expectedFrames = decodedFrames = droppedFrames = 0;
  }
  setInterval(monitorPerformance, 500);

  // =================== È°µÈù¢ÂàùÂßãÂåñ ===================
  //createSocket();
  // =================== ÂéãÂäõÊµãËØï: ÊØè10ÁßíÊï¥È°µÂà∑Êñ∞ ===================
  /*setInterval(() => {
    console.warn('‚ö†Ô∏è ÂéãÊµãÔºö10s Âº∫Âà∂Âà∑Êñ∞È°µÈù¢');
    location.reload(); // Áõ¥Êé•Âà∑Êñ∞Êï¥‰∏™È°µÈù¢
  }, 10000);*/



  // ---------------------- WebRTC Track Ê®°Âºè ----------------------
    // ---------------------- WebRTC Track Ê®°Âºè ----------------------
  async function initWebRTCTrack() {
    console.log('‚úÖ ‰ΩøÁî® WebRTC Track Ê®°Âºè');

    // ---- Ê∏ÖÁêÜÊóßËøûÊé• ----
    try { if (socket) { socket.close(); socket = null; } } catch(e){}
    try { if (pc) { pc.close(); pc = null; } } catch(e){}

    frameQueue = [];
    canvas.style.display = 'none';

    // ---- ÂàõÂª∫ video ÂÖÉÁ¥† ----
    let videoEl = document.getElementById('remoteVideo');
    if (!videoEl) {
      videoEl = document.createElement('video');
      videoEl.id = 'remoteVideo';
      videoEl.autoplay = true;
      videoEl.playsInline = true;
      videoEl.muted = true; // ÂøÖÈ°ªÈùôÈü≥ÊâçËÉΩËá™Âä®Êí≠Êîæ
      videoEl.style.position = 'absolute';
      videoEl.style.top = '0';
      videoEl.style.left = '0';
      videoEl.style.right = '0';
      videoEl.style.bottom = '0';
      videoEl.style.margin = 'auto';
      videoEl.style.maxWidth = '100%';
      videoEl.style.maxHeight = '100%';
      document.body.appendChild(videoEl);
    }
    videoEl.style.display = 'block';

    // ---- ÂàõÂª∫ PeerConnection ----
    pc = new RTCPeerConnection({
      iceServers: [
        {
          urls: 'turn:cnt.androidcloudtest.com:3478',
          username: token.slice(0, 8),
          credential: token.slice(8),
        }
      ]
    });

    // ---- Track ÂõûË∞É ----
    pc.ontrack = (event) => {
      console.log("üé¨ Êî∂Âà∞ËøúÁ´Ø track:", event.streams[0]);
      videoEl.srcObject = event.streams[0];
      videoEl.play().catch(err => console.warn("video play err", err));
      // üëá Ê∑ªÂä†‰∫§‰∫íÁªëÂÆö
      bindInteraction(videoEl);
      /*if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ codec: `vp8` }));
        //safeSend(JSON.stringify({ bit_rate: `50000` }));
        //safeSend(JSON.stringify({ webrtc: `true` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }*/
    };

    // ---- ICE ÂõûË∞É ----
    pendingICE = [];
    pc.onicecandidate = e => {
      console.log('candidate:', e.candidate);
      if (e.candidate && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ cmd: 'webrtc_ice', candidate: e.candidate }));
      } else if (e.candidate) {
        pendingICE.push(e.candidate);
      }
    };

    // ---- ÂàõÂª∫ WS ‰ø°‰ª§ËøûÊé• ----
    socket = new WebSocket(`${urls}/?token=${token}`);
    socket.onopen = async () => {
      console.log('‚úÖ WebRTC ‰ø°‰ª§ WS Â∑≤ËøûÊé•');

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ codec: `vp8` }));
        safeSend(JSON.stringify({ bit_rate: `50000` }));
        //safeSend(JSON.stringify({ webrtc: `true` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      try {
        // Ê∑ªÂä†Êé•Êî∂Á´Ø TransceiverÔºàÁ°Æ‰øù SDP ‰∏≠Êúâ m=videoÔºâ
        pc.addTransceiver('video', { direction: 'recvonly' });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        socket.send(JSON.stringify({
          cmd: 'webrtc_offer',
          offer: pc.localDescription
        }));
        console.log('üì§ Â∑≤ÂèëÈÄÅ WebRTC Offer');
      } catch (err) {
        console.error('‚ùå ÂàõÂª∫ Offer Â§±Ë¥•:', err);
      }
    };

    // ---- Â§ÑÁêÜ‰ø°‰ª§Ê∂àÊÅØ ----
    socket.onmessage = async e => {
      const data = e.data;
      //console.log("Êî∂Âà∞Ê∂àÊÅØÁ±ªÂûã:", typeof e.data, e.data);

      if (typeof data === 'string') {
        // JSON ‰ø°‰ª§
        let msg;
        try { msg = JSON.parse(data); } catch { return; }

        if (msg.cmd === 'webrtc_answer') {
          await pc.setRemoteDescription(msg.answer);
          // Ê∑ªÂä† pending ICE
          for (const c of pendingICE) await pc.addIceCandidate(c);
          pendingICE = [];
          return;
        }
        if (msg.cmd === 'webrtc_ice') {
          if (pc.remoteDescription) await pc.addIceCandidate(msg.candidate);
          else pendingICE.push(msg.candidate);
          return;
        }

        if (msg.cmd === 'pong') { latency = performance.now() - pingStartTime; return; }
        if (msg.error) { console.error('ÊúçÂä°Á´ØÈîôËØØ', msg.error); return; }

        return;
      }

      // ‰∫åËøõÂà∂Êï∞ÊçÆÂ§ÑÁêÜ
      if (e.data instanceof Blob) {
        const reader = new FileReader();
        reader.onload = () => {
          const buffer = new Uint8Array(reader.result);
          handleBinary(buffer);
        };
        reader.readAsArrayBuffer(e.data);
      } else if (e.data instanceof ArrayBuffer) {
        const buffer = new Uint8Array(e.data);
        handleBinary(buffer);
      } else {
        console.warn("Êú™Áü•‰∫åËøõÂà∂Á±ªÂûã:", e.data);
      }

      // ‰∫åËøõÂà∂Êï∞ÊçÆÔºàÊôÆÈÄö WS ÂèëÁöÑÔºâ
      /*const buffer = new Uint8Array(data);
      const type = buffer[0];
      const payload = buffer.slice(1);

      switch(type){
        case 0x01: frameQueue.push(payload); decodeNextFrame(); break;
        case 0x02: playPCM(payload); break;
        case 0x03: console.log("ÈîÆÁõòÊåá‰ª§ show =", payload[0]); break;
        case 0x04: 
          if(payload.length>=8){
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            photoRegion = { left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
            showPhoto = true;
          } else photoRegion = null;
          break;
        case 0x05: console.log("ready", payload[0]); break;
        default: console.warn("Êú™Áü•‰∫åËøõÂà∂Á±ªÂûã:", type);
      }*/
    };

    socket.onclose = () => {
      console.warn('‚ö†Ô∏è WebRTC ‰ø°‰ª§ WS Êñ≠ÂºÄÔºå2 ÁßíÂêéÈáçËøû');
      setTimeout(initWebRTCTrack, 2000);
    };

    socket.onerror = e => console.warn('WebRTC WS ÈîôËØØ:', e);
  }

  function handleBinary(buffer) {
    if (!buffer || buffer.length === 0) return;

    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("ÈîÆÁõòÊåá‰ª§ show =", payload[0]); break;
      case 0x04: 
        console.log("0x04");
        if(payload.length>=8){
          const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
          photoRegion = { left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto = true;
        } else photoRegion = null;
        break;
      case 0x05: console.log("ready", payload[0]); break;
      default: //console.warn("Êú™Áü•‰∫åËøõÂà∂Á±ªÂûã:", type); 
        break;
    }
  }

  function bindInteraction(el) {
    let isDown = false;
    el.addEventListener('mousedown', e => {
      isDown = true;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ start: `${x},${y}` }));
      sendDown(x, y);
    });

    el.addEventListener('mousemove', e => {
      if (!isDown) return;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ swipe: `${x},${y}` }));
      sendMove(x, y);
    });

    el.addEventListener('mouseup', e => {
      if (!isDown) return;
      isDown = false;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ end: `${x},${y}` }));
      sendUp(x, y);
    });

    el.addEventListener('touchstart', e => {
      e.preventDefault();
      isDown = true;
      const rect = el.getBoundingClientRect();
      const t = e.touches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ start: `${x},${y}` }));
      sendDown(x, y)
    }, { passive: false });

    el.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!isDown) return;
      const rect = el.getBoundingClientRect();
      const t = e.touches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ swipe: `${x},${y}` }));
      sendMove(x, y);
    }, { passive: false });

    el.addEventListener('touchend', e => {
      e.preventDefault();
      if (!isDown) return;
      isDown = false;
      const rect = el.getBoundingClientRect();
      const t = e.changedTouches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ end: `${x},${y}` }));
      sendUp(x, y);
    }, { passive: false });
  }

  </script>
</body>

</html>
