<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebCodecs H264 + PCM æ’­æ”¾å™¨ï¼ˆå¯ä¿å­˜ï¼‰</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #saveButton { top: 100px; left: 10px; }
    #uploadBtn {
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
  <canvas id="canvas"></canvas>
  <button id="saveButton" onclick="downloadStreams()">é€‰æ‹©ç…§ç‰‡</button>
  <button id="uploadBtn">é€‰æ‹©ç…§ç‰‡</button>
  <input type="file" id="fileInput" accept="image/*" style="display:none" />
  <div id="latencyDisplay">â± å»¶æ—¶: -- ms | ğŸ FPS: -- | âŒ› è§£ç : -- ms</div>

  <script>
  // =================== WebSocket è‡ªåŠ¨é‡è¿ä¸å‘é€ ===================
  let socket = null, reconnectTimer = null, connect = false, os = "";
  let latency = '--', pingStartTime = 0, pingInterval = null;

  // === æ–°å¢: æ‰å¸§ç»Ÿè®¡å˜é‡ ===
  let expectedFrames = 0, decodedFrames = 0, droppedFrames = 0;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=188ce7651a786798012f76811a9fdc05');
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('âœ… WebSocket å·²è¿æ¥');
      if (reconnectTimer) clearTimeout(reconnectTimer);
      document.getElementById('latencyDisplay').textContent = `âœ… å·²è¿æ¥ | â± å»¶æ—¶: -- ms | ğŸ FPS: -- | âŒ› è§£ç : -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] âŒ WebSocket å·²æ–­å¼€ï¼Œ2ç§’åå°è¯•é‡è¿`);
      document.getElementById('latencyDisplay').textContent = 'âŒ è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) reconnectTimer = setTimeout(createSocket, 2000);
    };

    socket.onerror = e => console.warn('WebSocket é”™è¯¯:', e);
    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) socket.send(data);
    else console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend è¢«å¿½ç•¥:', data);
  }

  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // =================== Canvas & WebCodecs è§†é¢‘è§£ç  ===================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0, lastFpsTime = performance.now(), currentFps = 0;
  let videoDecoder = null, frameQueue = [], MAX_FRAME_QUEUE = 10, decoding = false;
  let isStart = false, lastVideoPTS = 0, startTime = 0;

  // === æ–°å¢: ä¿å­˜æ¯ä¸ªPTSçš„æ¥æ”¶æ—¶é—´ ===
  const recvTimeMap = new Map();
  let lastDecodeCost = '--';

  function initDecoder() {
    videoDecoder = new VideoDecoder({
      output: frame => {
        const pts = frame.timestamp;
        const endTime = performance.now();
        if (recvTimeMap.has(pts)) {
          const cost = endTime - recvTimeMap.get(pts);
          lastDecodeCost = cost.toFixed(2); // ä¿å­˜è€—æ—¶(ms)
          //console.log(`ğŸ¯ PTS=${pts} è§£ç è€—æ—¶: ${lastDecodeCost} ms`);
          recvTimeMap.delete(pts);
        }

        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
        frame.close();
        decodedFrames++;
      },
      error: e => console.error('VideoDecoder error:', e)
    });

    videoDecoder.configure({
      codec: 'avc1.42E01E',
      codedWidth: 720,
      codedHeight: 1280,
      optimizeForLatency: true,
      hardwareAcceleration: "prefer-hardware",
    });

    isStart = false;
  }
  initDecoder();

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        if ((payload[i+4] & 0x1F) === 5) return true;
      }
    }
    return false;
  }

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payloadWithPTS = frameQueue.shift();
    expectedFrames++;
    const ptsView = new DataView(payloadWithPTS.buffer, payloadWithPTS.byteOffset, 8);
    const ptsUs = ptsView.getBigUint64(0);
    const nalu = payloadWithPTS.slice(8);
    const isKey = isIDR(nalu);

    if (!isKey && !isStart) return;

    decoding = true;

    try {
      if (isKey) {
        isStart = true;
        lastVideoPTS = Number(ptsUs) / 1000;
        startTime = performance.now();
      }

      const targetTime = startTime + (Number(ptsUs) / 1000 - lastVideoPTS);
      const delay = targetTime - performance.now();

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: Number(ptsUs),
        data: nalu
      });

      // === æ–°å¢: è®°å½•æ¥æ”¶æ—¶é—´ ===
      recvTimeMap.set(Number(ptsUs), performance.now());

      if (delay > 0) {
        setTimeout(() => {
          videoDecoder.decode(chunk);
          decoding = false;
          setTimeout(decodeNextFrame, 0);
        }, delay);
      } else {
        videoDecoder.decode(chunk);
        decoding = false;
        setTimeout(decodeNextFrame, 0);
      }
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder.state !== 'closed') videoDecoder.close(); } catch(e){console.warn(e);}
    initDecoder();
    console.log('âœ… Decoder é‡å»ºæˆåŠŸï¼Œç­‰å¾…å…³é”®å¸§');
  }

  // =================== éŸ³é¢‘æ’­æ”¾ ===================
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000, channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        channelData[i] = int16Data[i * channelCount + ch] / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => source.disconnect();
  }

  // =================== Canvas ç¼©æ”¾é€‚é… ===================
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    let displayWidth = window.innerWidth;
    let displayHeight = displayWidth / aspectRatio;

    if (displayHeight > window.innerHeight) {
      displayHeight = window.innerHeight;
      displayWidth = displayHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // =================== æ»‘åŠ¨ä¼˜åŒ– ===================
  let isDown = false, moveQueue = [], showPhoto = false, photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (clientX - rect.left) * (canvas.width / rect.width),
      y: (clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { moveQueue.push({x,y}); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const inside = x >= photoRegion.left && x <= photoRegion.right && y >= photoRegion.top && y <= photoRegion.bottom;
      if (inside) { showPhoto = false; photoRegion = null; uploadBtn.click(); }
    }
  }

  // æ‰¹é‡å‘é€ move äº‹ä»¶ï¼Œç»‘å®š requestAnimationFrame
  function flushMoveQueue() {
    if (moveQueue.length > 0) {
      const last = moveQueue[moveQueue.length - 1];
      safeSend(JSON.stringify({ swipe: `${last.x},${last.y}` }));
      moveQueue = [];
    }
    requestAnimationFrame(flushMoveQueue);
  }
  requestAnimationFrame(flushMoveQueue);

  // é¼ æ ‡äº‹ä»¶
  canvas.addEventListener('mousedown', e => { isDown=true; const c=getCanvasCoords(e.clientX,e.clientY); sendDown(c.x,c.y); });
  canvas.addEventListener('mousemove', e => { if(!isDown) return; const c=getCanvasCoords(e.clientX,e.clientY); sendMove(c.x,c.y); });
  canvas.addEventListener('mouseup', e => { if(!isDown) return; isDown=false; const c=getCanvasCoords(e.clientX,e.clientY); sendUp(c.x,c.y); });

  // è§¦æ‘¸äº‹ä»¶
  canvas.addEventListener('touchstart', e => { e.preventDefault(); if(e.touches.length===0) return; isDown=true; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendDown(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!isDown) return; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendMove(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchend', e => { e.preventDefault(); if(!isDown) return; isDown=false; if(e.changedTouches.length===0) return; const t=getCanvasCoords(e.changedTouches[0].clientX,e.changedTouches[0].clientY); sendUp(t.x,t.y); }, {passive:false});

  // =================== WebSocket æ¶ˆæ¯å¤„ç† ===================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd==='pong') { 
          latency = Math.round(performance.now()-pingStartTime); 
          document.getElementById('latencyDisplay').textContent=
            `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps} | âŒ› è§£ç : ${lastDecodeCost} ms`;
        }
      } catch(e){ console.warn('JSON è§£æå¤±è´¥:', e); }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x01:
        if(frameQueue.length>=MAX_FRAME_QUEUE){ 
          const idx=frameQueue.findIndex(buf=>!isIDR(buf));
          if (idx!==-1) {
            frameQueue.splice(idx,1);
            droppedFrames++;
          } else {
            frameQueue.shift();
            droppedFrames++;
          }
          console.warn('âš ï¸ ä¸¢å¸§ä»¥æ§åˆ¶å»¶è¿Ÿ');
        }
        frameQueue.push(payload);
        decodeNextFrame();
        break;
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("é”®ç›˜æŒ‡ä»¤ show =",payload[0]); break;
      case 0x04: 
        if(payload.length>=8){
          const view=new DataView(payload.buffer,payload.byteOffset,payload.byteLength);
          photoRegion={ left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto=true;
          console.log("ğŸ“¸ ç…§ç‰‡åŒºåŸŸåæ ‡:", photoRegion);
        }else{ photoRegion=null; console.warn('âš ï¸ æ”¶åˆ°0x04æ•°æ®é•¿åº¦ä¸è¶³'); }
        break;
      case 0x05: console.log("ready", payload[0]); break;
    }
  }

  // =================== å›¾ç‰‡ä¸Šä¼  ===================
  const fileInput=document.getElementById('fileInput');
  const saveButton=document.getElementById('saveButton');
  const uploadBtn=document.getElementById('uploadBtn');
  let lastImageData=null;

  uploadBtn.onclick=()=>fileInput.click();

  fileInput.onchange=()=>{
    const file=fileInput.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      const uint8Arr=new Uint8Array(reader.result);
      console.log('ğŸ“· é€‰ä¸­å›¾ç‰‡ï¼Œå¤§å°:', uint8Arr.length);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    console.warn('downloadStreams');
    safeSend(JSON.stringify({ bit_rate: `600000` }));
  }

  const CHUNK_SIZE=64*1024;
  function safeSendPhoto(data){
    if(!socket || socket.readyState!==WebSocket.OPEN){ console.warn('âš ï¸ WebSocket æœªè¿æ¥ï¼Œsend photo è¢«å¿½ç•¥'); return; }

    console.warn(`[${new Date().toLocaleString()}] ğŸ“¤ å¼€å§‹å‘é€å›¾ç‰‡ï¼Œå¤§å°: ${data.length} bytes`);
    const totalChunks=Math.ceil(data.length/CHUNK_SIZE);
    const uid=Date.now();

    for(let i=0;i<totalChunks;i++){
      const chunk=data.slice(i*CHUNK_SIZE,(i+1)*CHUNK_SIZE);
      const message={ type:'photo_chunk', uid, index:i, total:totalChunks, data:Array.from(chunk) };
      socket.send(JSON.stringify(message));
    }
    console.warn(`[${new Date().toLocaleString()}] âœ… å›¾ç‰‡æ‹†åŒ…å‘é€å®Œæˆï¼Œå…± ${totalChunks} å—`);
  }

  // =================== æ‰å¸§ç‡ç»Ÿè®¡ & åˆ¤åˆ«ç½‘ç»œ/æ€§èƒ½ ===================
  setInterval(() => {
    if (expectedFrames === 0) return;
    const dropRate = (droppedFrames / expectedFrames) * 100;
    console.log(`ğŸ“Š æ‰å¸§ç‡: ${dropRate.toFixed(2)}% (æ”¶åˆ°:${expectedFrames}, è§£ç :${decodedFrames}, ä¸¢å¼ƒ:${droppedFrames})`);

    if (dropRate > 10) {
      if (latency !== '--' && latency > 150) {
        console.warn("âš ï¸ æ‰å¸§ç‡é«˜ï¼Œå¯èƒ½æ˜¯ç½‘ç»œå¸¦å®½/å»¶è¿Ÿä¸è¶³");
      } else {
        console.warn("âš ï¸ æ‰å¸§ç‡é«˜ï¼Œå¯èƒ½æ˜¯æµè§ˆå™¨æ€§èƒ½ä¸è¶³å¯¼è‡´è§£ç è·Ÿä¸ä¸Š");
      }
    }

    expectedFrames = decodedFrames = droppedFrames = 0;
  }, 5000);

  // =================== é¡µé¢åˆå§‹åŒ– ===================
  createSocket();

  // === FPS æ¯ç§’æ›´æ–° ===
  setInterval(() => {
    const now = performance.now();
    currentFps = Math.round(decodedFrames / ((now - lastFpsTime) / 1000)); // FPS æ•´æ•°æ˜¾ç¤º
    lastFpsTime = now;
    document.getElementById('latencyDisplay').textContent =
      `â± å»¶æ—¶: ${latency} ms | ğŸ FPS: ${currentFps} | âŒ› è§£ç : ${lastDecodeCost} ms`;
    decodedFrames = 0;
  }, 1000);
  </script>
</body>
</html>