<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebCodecs H264 + PCM 播放器（可保存）</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #saveButton { top: 100px; left: 10px; }
    #uploadBtn {
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
      display: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
  <canvas id="canvas"></canvas>
  <button id="saveButton" onclick="downloadStreams()">选择照片</button>
  <button id="uploadBtn">选择照片</button>
  <input type="file" id="fileInput" accept="image/*" style="display:none" />
  <div id="latencyDisplay">延时: -- ms | 解码: -- ms</div>

  <script>
  // =================== WebSocket 自动重连与发送 ===================
  let socket = null, reconnectTimer = null, connect = false, os = "";
  let latency = '--', pingStartTime = 0, pingInterval = null;

  // === 新增: 掉帧统计变量 ===
  let expectedFrames = 0, decodedFrames = 0, droppedFrames = 0;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/?token=81a89b2d4a1715703325eb2a09e53f8a'); //wss://cn2.androidcloudtest.com ws://192.168.190.4:3000 wss://cloudphonews.com 
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('✅ WebSocket 已连接');
      if (reconnectTimer) clearTimeout(reconnectTimer);
      document.getElementById('latencyDisplay').textContent = `✅ 已连接 | 延时: -- ms | 解码: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ codec: `h264` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] ❌ WebSocket 已断开，2秒后尝试重连`);
      document.getElementById('latencyDisplay').textContent = '❌ 连接断开，正在重连...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) reconnectTimer = setTimeout(createSocket, 2000);
    };

    socket.onerror = e => console.warn('WebSocket 错误:', e);
    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) socket.send(data);
    else console.warn('⚠️ WebSocket 未连接，send 被忽略:', data);
  }

  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // =================== Canvas & WebCodecs 视频解码 ===================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let videoDecoder = null, frameQueue = [], MAX_FRAME_QUEUE = 10, decoding = false;
  let isStart = false, lastVideoPTS = 0, startTime = 0;

  // === 新增: 保存每个PTS的接收时间 ===
  const recvTimeMap = new Map();
  let lastDecodeCost = '--';

  function initDecoder() {
    if (typeof VideoDecoder === 'undefined' || !('isConfigSupported' in VideoDecoder)) {
      console.error('❌ 当前浏览器不支持 WebCodecs VideoDecoder');
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('WebCodecs 不受支持', canvas.width / 2, canvas.height / 2);
      initWebRTCTrack();
      return;
    }

    videoDecoder = new VideoDecoder({
      output: frame => {
        const pts = frame.timestamp;
        const endTime = performance.now();
        if (recvTimeMap.has(pts)) {
          const cost = endTime - recvTimeMap.get(pts);
          lastDecodeCost = cost.toFixed(0); // 保存耗时(ms)
          recvTimeMap.delete(pts);
        }

        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
        frame.close();
        decodedFrames++;
      },
      error: e => console.error('VideoDecoder error:', e)
    });

    videoDecoder.configure({
      codec: 'avc1.42E01E',
      codedWidth: 720,
      codedHeight: 1280,
      optimizeForLatency: true,
      hardwareAcceleration: "prefer-hardware",
    });

    isStart = false;
    createSocket();
  }
  //initDecoder();
  initWebRTCTrack();

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        if ((payload[i+4] & 0x1F) === 5) return true;
      }
    }
    return false;
  }

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payloadWithPTS = frameQueue.shift();
    expectedFrames++;

    const ptsView = new DataView(payloadWithPTS.buffer, payloadWithPTS.byteOffset, 8);
    const ptsUs = Number(ptsView.getBigUint64(0));
    const nalu = payloadWithPTS.slice(8);
    const isKey = isIDR(nalu);

    if (!isKey && !isStart) return;

    decoding = true;

    try {
      if (isKey && !isStart) {
        isStart = true;
        lastVideoPTS = ptsUs / 1000;
        startTime = performance.now();
      }

      const targetTime = startTime + (ptsUs / 1000 - lastVideoPTS);
      let delay = targetTime - performance.now();

      if (delay < -2000) delay = 0; // 延迟超过2s → 立即解码

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: ptsUs,
        data: nalu
      });

      recvTimeMap.set(ptsUs, performance.now());

      if (delay > 0) {
        setTimeout(() => {
          videoDecoder.decode(chunk);
          decoding = false;
          setTimeout(decodeNextFrame, 0);
        }, delay);
      } else {
        videoDecoder.decode(chunk);
        decoding = false;
        setTimeout(decodeNextFrame, 0);
      }
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder.state !== 'closed') videoDecoder.close(); } catch(e){console.warn(e);}
    initDecoder();
    console.log('✅ Decoder 重建成功，等待关键帧');
  }

  // =================== 音频播放 ===================
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000, channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        channelData[i] = int16Data[i * channelCount + ch] / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => source.disconnect();
  }

  // =================== Canvas 缩放适配 ===================
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    let displayWidth = window.innerWidth;
    let displayHeight = displayWidth / aspectRatio;

    if (displayHeight > window.innerHeight) {
      displayHeight = window.innerHeight;
      displayWidth = displayHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // =================== 鼠标 & 触摸事件 ===================
  let isDown = false, moveQueue = [], showPhoto = false, photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (clientX - rect.left) * (canvas.width / rect.width),
      y: (clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { moveQueue.push({x,y}); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const inside = x >= photoRegion.left && x <= photoRegion.right && y >= photoRegion.top && y <= photoRegion.bottom;
      if (inside) { showPhoto = false; photoRegion = null; uploadBtn.click(); }
    }
  }

  function flushMoveQueue() {
    if (moveQueue.length > 0) {
      const last = moveQueue[moveQueue.length - 1];
      safeSend(JSON.stringify({ swipe: `${last.x},${last.y}` }));
      moveQueue = [];
    }
    requestAnimationFrame(flushMoveQueue);
  }
  requestAnimationFrame(flushMoveQueue);

  canvas.addEventListener('mousedown', e => { isDown=true; const c=getCanvasCoords(e.clientX,e.clientY); sendDown(c.x,c.y); });
  canvas.addEventListener('mousemove', e => { if(!isDown) return; const c=getCanvasCoords(e.clientX,e.clientY); sendMove(c.x,c.y); });
  canvas.addEventListener('mouseup', e => { if(!isDown) return; isDown=false; const c=getCanvasCoords(e.clientX,e.clientY); sendUp(c.x,c.y); });

  canvas.addEventListener('touchstart', e => { e.preventDefault(); if(e.touches.length===0) return; isDown=true; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendDown(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!isDown) return; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendMove(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchend', e => { e.preventDefault(); if(!isDown) return; isDown=false; if(e.changedTouches.length===0) return; const t=getCanvasCoords(e.changedTouches[0].clientX,e.changedTouches[0].clientY); sendUp(t.x,t.y); }, {passive:false});

  // =================== WebSocket 消息处理 ===================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd==='pong') { 
          latency = Math.round(performance.now()-pingStartTime); 
        }
        // 可以根据 msg.error 做处理
        if (msg.error) {
          console.error('服务端错误:', msg.error);
        }
      } catch(e){ console.warn('JSON 解析失败:', e); }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x01:
        if(frameQueue.length>=MAX_FRAME_QUEUE){ 
          const idx=frameQueue.findIndex(buf=>!isIDR(buf));
          if (idx!==-1) {
            frameQueue.splice(idx,1);
            droppedFrames++;
          } else {
            frameQueue.shift();
            droppedFrames++;
          }
        }
        frameQueue.push(payload);
        decodeNextFrame();
        break;
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("键盘指令 show =",payload[0]); break;
      case 0x04: 
        if(payload.length>=8){
          const view=new DataView(payload.buffer,payload.byteOffset,payload.byteLength);
          photoRegion={ left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto=true;
        } else { photoRegion=null; }
        break;
      case 0x05: console.log("ready", payload[0]); break;
    }
  }

  // =================== 图片上传 ===================
  const fileInput=document.getElementById('fileInput');
  const saveButton=document.getElementById('saveButton');
  const uploadBtn=document.getElementById('uploadBtn');

  uploadBtn.onclick=()=>fileInput.click();

  fileInput.onchange=()=>{
    const file=fileInput.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      const uint8Arr=new Uint8Array(reader.result);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    safeSend(JSON.stringify({ bit_rate: `600000` }));
  }

  const CHUNK_SIZE=64*1024;
  function safeSendPhoto(data){
    if(!socket || socket.readyState!==WebSocket.OPEN) return;
    const totalChunks=Math.ceil(data.length/CHUNK_SIZE);
    const uid=Date.now();

    for(let i=0;i<totalChunks;i++){
      const chunk=data.slice(i*CHUNK_SIZE,(i+1)*CHUNK_SIZE);
      const message={ type:'photo_chunk', uid, index:i, total:totalChunks, data:Array.from(chunk) };
      socket.send(JSON.stringify(message));
    }
  }

  // =================== 统一性能监控 ===================
  function monitorPerformance() {
    const totalQueueBytes = frameQueue.reduce((sum, buf) => sum + buf.byteLength, 0);
    const dropRate = expectedFrames > 0 ? (droppedFrames / expectedFrames) * 100 : 0;
    const decodeTime = parseFloat(lastDecodeCost) || 0;
    const currentLatency = latency !== '--' ? latency : 0;

    if (socket && socket.readyState === WebSocket.OPEN) {
      safeSend(JSON.stringify({
        cmd: 'performance',
        latencyPlusDecode: currentLatency + decodeTime, // 延时+解码
        dropRate: dropRate.toFixed(0),
        queueBytes: totalQueueBytes
      }));
    }

    document.getElementById('latencyDisplay').textContent =
      `延时+解码: ${currentLatency + decodeTime} ms | 掉帧率: ${dropRate.toFixed(1)}% | 队列: ${(totalQueueBytes/1024).toFixed(0)} KB`;

    expectedFrames = decodedFrames = droppedFrames = 0;
  }
  setInterval(monitorPerformance, 500);

  // =================== 页面初始化 ===================
  //createSocket();
  // =================== 压力测试: 每10秒整页刷新 ===================
  /*setInterval(() => {
    console.warn('⚠️ 压测：10s 强制刷新页面');
    location.reload(); // 直接刷新整个页面
  }, 10000);*/

  // ---------------------- WebRTC Track 模式 ----------------------
    // ---------------------- WebRTC Track 模式 ----------------------
  async function initWebRTCTrack() {
    console.log('✅ 使用 WebRTC Track 模式');

    // ---- 清理旧连接 ----
    try { if (socket) { socket.close(); socket = null; } } catch(e){}
    try { if (pc) { pc.close(); pc = null; } } catch(e){}

    frameQueue = [];
    canvas.style.display = 'none';

    // ---- 创建 video 元素 ----
    let videoEl = document.getElementById('remoteVideo');
    if (!videoEl) {
      videoEl = document.createElement('video');
      videoEl.id = 'remoteVideo';
      videoEl.autoplay = true;
      videoEl.playsInline = true;
      videoEl.muted = true; // 必须静音才能自动播放
      videoEl.style.position = 'absolute';
      videoEl.style.top = '0';
      videoEl.style.left = '0';
      videoEl.style.right = '0';
      videoEl.style.bottom = '0';
      videoEl.style.margin = 'auto';
      videoEl.style.maxWidth = '100%';
      videoEl.style.maxHeight = '100%';
      document.body.appendChild(videoEl);
    }
    videoEl.style.display = 'block';

    // ---- 创建 PeerConnection ----
    /*pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },  // 可选，做 fallback
        {
          urls: 'turn:47.113.122.0:3478',
          username: 'webrtc',
          credential: '123456'
        }
      ]
    });*/
    const pc = new RTCPeerConnection({
        iceServers: [], // 空列表，不请求 STUN
    });

    // ---- Track 回调 ----
    pc.ontrack = (event) => {
      console.log("🎬 收到远端 track:", event.streams[0]);
      videoEl.srcObject = event.streams[0];
      videoEl.play().catch(err => console.warn("video play err", err));
      // 👇 添加交互绑定
      bindInteraction(videoEl);
    };

    // ---- ICE 回调 ----
    pendingICE = [];
    pc.onicecandidate = e => {
      if (e.candidate && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ cmd: 'webrtc_ice', candidate: e.candidate }));
      } else if (e.candidate) {
        pendingICE.push(e.candidate);
      }
    };

    // ---- 创建 WS 信令连接 ----
    socket = new WebSocket('wss://cn2.androidcloudtest.com/?token=ac2a05a918af064ec805c84f5801d649');
    socket.onopen = async () => {
      console.log('✅ WebRTC 信令 WS 已连接');

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ codec: `vp8` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      try {
        // 添加接收端 Transceiver（确保 SDP 中有 m=video）
        pc.addTransceiver('video', { direction: 'recvonly' });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        socket.send(JSON.stringify({
          cmd: 'webrtc_offer',
          offer: pc.localDescription
        }));
        console.log('📤 已发送 WebRTC Offer');
      } catch (err) {
        console.error('❌ 创建 Offer 失败:', err);
      }
    };

    // ---- 处理信令消息 ----
    socket.onmessage = async e => {
      const data = e.data;
      //console.log("收到消息类型:", typeof e.data, e.data);

      if (typeof data === 'string') {
        // JSON 信令
        let msg;
        try { msg = JSON.parse(data); } catch { return; }

        if (msg.cmd === 'webrtc_answer') {
          await pc.setRemoteDescription(msg.answer);
          // 添加 pending ICE
          for (const c of pendingICE) await pc.addIceCandidate(c);
          pendingICE = [];
          return;
        }
        if (msg.cmd === 'webrtc_ice') {
          if (pc.remoteDescription) await pc.addIceCandidate(msg.candidate);
          else pendingICE.push(msg.candidate);
          return;
        }

        if (msg.cmd === 'pong') { latency = performance.now() - pingStartTime; return; }
        if (msg.error) { console.error('服务端错误', msg.error); return; }

        return;
      }

      // 二进制数据处理
      if (e.data instanceof Blob) {
        const reader = new FileReader();
        reader.onload = () => {
          const buffer = new Uint8Array(reader.result);
          handleBinary(buffer);
        };
        reader.readAsArrayBuffer(e.data);
      } else if (e.data instanceof ArrayBuffer) {
        const buffer = new Uint8Array(e.data);
        handleBinary(buffer);
      } else {
        console.warn("未知二进制类型:", e.data);
      }

      // 二进制数据（普通 WS 发的）
      /*const buffer = new Uint8Array(data);
      const type = buffer[0];
      const payload = buffer.slice(1);

      switch(type){
        case 0x01: frameQueue.push(payload); decodeNextFrame(); break;
        case 0x02: playPCM(payload); break;
        case 0x03: console.log("键盘指令 show =", payload[0]); break;
        case 0x04: 
          if(payload.length>=8){
            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            photoRegion = { left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
            showPhoto = true;
          } else photoRegion = null;
          break;
        case 0x05: console.log("ready", payload[0]); break;
        default: console.warn("未知二进制类型:", type);
      }*/
    };

    socket.onclose = () => {
      console.warn('⚠️ WebRTC 信令 WS 断开，2 秒后重连');
      setTimeout(initWebRTCTrack, 2000);
    };

    socket.onerror = e => console.warn('WebRTC WS 错误:', e);
  }

  function handleBinary(buffer) {
    if (!buffer || buffer.length === 0) return;

    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x01: frameQueue.push(payload); decodeNextFrame(); break;
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("键盘指令 show =", payload[0]); break;
      case 0x04: 
        console.log("0x04");
        if(payload.length>=8){
          const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
          photoRegion = { left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto = true;
        } else photoRegion = null;
        break;
      case 0x05: console.log("ready", payload[0]); break;
      default: //console.warn("未知二进制类型:", type); 
        break;
    }
  }

  function bindInteraction(el) {
    let isDown = false;
    el.addEventListener('mousedown', e => {
      isDown = true;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ start: `${x},${y}` }));
      sendDown(x, y);
    });

    el.addEventListener('mousemove', e => {
      if (!isDown) return;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ swipe: `${x},${y}` }));
      sendMove(x, y);
    });

    el.addEventListener('mouseup', e => {
      if (!isDown) return;
      isDown = false;
      const rect = el.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (720 / rect.width);
      const y = (e.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ end: `${x},${y}` }));
      sendUp(x, y);
    });

    el.addEventListener('touchstart', e => {
      e.preventDefault();
      isDown = true;
      const rect = el.getBoundingClientRect();
      const t = e.touches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ start: `${x},${y}` }));
      sendDown(x, y)
    }, { passive: false });

    el.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!isDown) return;
      const rect = el.getBoundingClientRect();
      const t = e.touches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ swipe: `${x},${y}` }));
      sendMove(x, y);
    }, { passive: false });

    el.addEventListener('touchend', e => {
      e.preventDefault();
      if (!isDown) return;
      isDown = false;
      const rect = el.getBoundingClientRect();
      const t = e.changedTouches[0];
      const x = (t.clientX - rect.left) * (720 / rect.width);
      const y = (t.clientY - rect.top) * (1280 / rect.height);
      //safeSend(JSON.stringify({ end: `${x},${y}` }));
      sendUp(x, y);
    }, { passive: false });
  }

  </script>
</body>
</html>