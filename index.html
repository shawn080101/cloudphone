<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>WebCodecs H264 + PCM 播放器（iOS 16.7 修正版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      left: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #saveButton { top: 100px; }
    #uploadBtn { top: 150px; }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</head>
<body>
<canvas id="canvas"></canvas>
<button id="saveButton" onclick="downloadStreams()">选择照片</button>
<button id="uploadBtn">选择照片</button>
<input type="file" id="fileInput" accept="image/*" style="display:none" />
<div id="latencyDisplay">⏱ 延时: -- ms</div>

<script>
  // ============================
  // WebSocket 自动重连 + 安全发送
  // ============================
  let socket = null;
  let reconnectTimer = null;
  let connect = false;
  let os = "";
  let latency = '--';
  let pingStartTime = 0;
  let pingInterval = null;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=287467d5dc90550e9431a7226f03024d');
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('✅ WebSocket 已连接');
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      document.getElementById('latencyDisplay').textContent = `✅ 已连接 | 延时: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tcph0g://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }
      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] ❌ WebSocket 已断开，2秒后尝试重连`);
      document.getElementById('latencyDisplay').textContent = '❌ 连接断开，正在重连...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) {
        reconnectTimer = setTimeout(() => { createSocket(); }, 2000);
      }
    };

    socket.onerror = (e) => {
      console.warn('WebSocket 错误:', e);
    };

    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(data);
    } else {
      console.warn('⚠️ WebSocket 未连接，send 被忽略:', data);
    }
  }

  // ============================
  // 画布 & 显示
  // ============================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let lastFpsTime = performance.now();
  let currentFps = 0;

  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let displayWidth = windowWidth;
    let displayHeight = windowWidth / aspectRatio;

    if (displayHeight > windowHeight) {
      displayHeight = windowHeight;
      displayWidth = windowHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ============================
  // WebCodecs 视频解码（iOS 16.7 兼容）
  // 关键改动：
  // 1) 严格自增时间戳（us），从0开始
  // 2) output 里使用 createImageBitmap 再 drawImage
  // 3) 去掉 hardwareAcceleration 选项
  // 4) 首选 Main Profile，再回落到 Baseline
  // ============================

  let videoDecoder = null;

  async function configureDecoder() {
    if (videoDecoder && videoDecoder.state !== 'closed') {
      try { videoDecoder.close(); } catch (e) {}
    }

    const output = async (frame) => {
      try {
        // iOS 16.x: 直接 drawImage(VideoFrame) 偶发黑屏
        const bitmap = await createImageBitmap(frame);
        ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        bitmap.close();
      } finally {
        frame.close();
      }
      decodedFrameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        currentFps = decodedFrameCount;
        decodedFrameCount = 0;
        lastFpsTime = now;
        document.getElementById('latencyDisplay').textContent = `⏱ 延时: ${latency} ms | 🎞 FPS: ${currentFps}`;
      }
    };

    const error = (e) => console.error('VideoDecoder error:', e);

    videoDecoder = new VideoDecoder({ output, error });

    const candidates = [
      { codec: 'avc1.4d401f', codedWidth: 720, codedHeight: 1280, optimizeForLatency: true }, // Main@L3.1
      { codec: 'avc1.42E01E', codedWidth: 720, codedHeight: 1280, optimizeForLatency: true }, // Baseline@L3.0
    ];

    for (const cfg of candidates) {
      try {
        // Safari 16.7 的 isConfigSupported 可能返回乐观结果，这里直接尝试 configure，失败再回退
        await videoDecoder.configure(cfg);
        console.log('✅ 使用解码配置:', cfg.codec);
        return;
      } catch (e) {
        console.warn('⚠️ 配置失败，尝试下一个:', cfg.codec, e);
      }
    }

    console.error('❌ 没有可用的 H.264 解码配置');
  }

  // 严格自增的时间戳（微秒）
  const frameQueue = [];
  const MAX_FRAME_QUEUE = 10;
  let decoding = false;
  let isStart = false;
  let lastVideoTimestamp = 0;
  const frameDurationUs = Math.round(1000000 / 60); // 60fps 约 16667us
  let haveSps = false, havePps = false;

  function decodeNextFrame() {
    if (decoding) return;
    if (!videoDecoder || videoDecoder.state === 'closed') return;
    if (frameQueue.length === 0) return;
    if (videoDecoder.decodeQueueSize > 3) return;

    const payload = frameQueue.shift();

    const info = scanNal(payload);
    if (info.hasSps) haveSps = true;
    if (info.hasPps) havePps = true;
    const isKey = info.hasIdr;

    // 必须从 IDR 开始，且要在 IDR 前拿到 SPS/PPS
    if (!isStart) {
      if (!(isKey && haveSps && havePps)) {
        // 没到可用起点，继续等
        return;
      }
      isStart = true;
      lastVideoTimestamp = 0;
    } else {
      lastVideoTimestamp += frameDurationUs;
    }

    const chunk = new EncodedVideoChunk({
      type: isKey ? 'key' : 'delta',
      timestamp: lastVideoTimestamp,
      data: payload,
    });

    try {
      decoding = true;
      videoDecoder.decode(chunk);
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
    } finally {
      decoding = false;
      Promise.resolve().then(decodeNextFrame);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder && videoDecoder.state !== 'closed') videoDecoder.close(); } catch (e) { console.warn('关闭 decoder 失败:', e); }
    videoDecoder = null;
    isStart = false;
    haveSps = havePps = false;
    configureDecoder().then(() => {
      console.log('✅ Decoder 重建成功，等待关键帧+SPS/PPS');
    }).catch(e => console.error('❌ Decoder 恢复失败:', e));
  }

  // 扫描 Annex-B NAL：支持 00 00 00 01 和 00 00 01 起始码
  function scanNal(payload) {
    let hasIdr = false, hasSps_ = false, hasPps_ = false;
    for (let i = 0; i < payload.length - 4; i++) {
      // 00 00 01
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x01) {
        const nalType = payload[i+3] & 0x1F;
        if (nalType === 5) hasIdr = true;      // IDR
        if (nalType === 7) hasSps_ = true;     // SPS
        if (nalType === 8) hasPps_ = true;     // PPS
      }
      // 00 00 00 01
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        const nalType = payload[i+4] & 0x1F;
        if (nalType === 5) hasIdr = true;
        if (nalType === 7) hasSps_ = true;
        if (nalType === 8) hasPps_ = true;
      }
    }
    return { hasIdr, hasSps: hasSps_, hasPps: hasPps_ };
  }

  // ============================
  // 音频（PCM 16bit LE, 8kHz, mono）
  // ============================
  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000;
  const channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        const sample = int16Data[i * channelCount + ch];
        channelData[i] = sample / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => { source.disconnect(); };
  }

  // ============================
  // 触摸/鼠标事件透传
  // ============================
  let isDown = false;
  let throttleTimer = null;
  let showPhoto = false;
  let photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { safeSend(JSON.stringify({ swipe: `${x},${y}` })); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const { left, top, right, bottom } = photoRegion;
      const inside = x >= left && x <= right && y >= top && y <= bottom;
      if (inside) {
        console.log('✅ 点击在照片区域内:', x, y);
        showPhoto = false;
        photoRegion = null;
        uploadBtn.click();
      } else {
        console.log('❌ 点击在区域外:', x, y);
      }
    }
  }

  canvas.addEventListener('mousedown', e => {
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendDown(x, y);
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    e.preventDefault();
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('mouseup', e => {
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendUp(x, y);
  });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 0) return;
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendDown(x, y);
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    if (e.changedTouches.length === 0) return;
    const touch = e.changedTouches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendUp(x, y);
  }, { passive: false });

  // ============================
  // WebSocket 消息处理
  // ============================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd === 'pong') {
          const pingEndTime = performance.now();
          latency = Math.round(pingEndTime - pingStartTime);
          document.getElementById('latencyDisplay').textContent = `⏱ 延时: ${latency} ms | 🎞 FPS: ${currentFps}`;
        }
      } catch (e) {
        console.warn('JSON 解析失败:', e);
      }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    if (type === 0x01) { // 视频
      if (frameQueue.length >= MAX_FRAME_QUEUE) {
        const index = frameQueue.findIndex(buf => !scanNal(buf).hasIdr);
        if (index !== -1) {
          frameQueue.splice(index, 1);
        } else {
          frameQueue.shift();
        }
        console.warn('⚠️ 丢帧以控制延迟');
      }
      frameQueue.push(payload);
      decodeNextFrame();
    } else if (type === 0x02) { // 音频
      try { playPCM(payload); } catch (err) { console.error('PCM 播放出错:', err); }
    } else if (type === 0x03) { // 键盘
      const show = payload[0];
      console.log("键盘指令 show =", show);
    } else if (type === 0x04) { // 照片区域
      if (payload.length >= 8) {
        const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        const left = view.getInt16(0);
        const top = view.getInt16(2);
        const right = view.getInt16(4);
        const bottom = view.getInt16(6);
        console.log("📸 照片区域坐标:", left, top, right, bottom);
        photoRegion = { left, top, right, bottom };
        showPhoto = true;
      } else {
        photoRegion = null;
        console.warn('⚠️ 收到0x04数据长度不足');
      }
    } else if (type === 0x05) { // ready
      console.log("ready", payload[0]);
    }
  }

  // ============================
  // Ping for latency
  // ============================
  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // ============================
  // 选择照片上传（分片）
  // ============================
  const fileInput = document.getElementById('fileInput');
  const saveButton = document.getElementById('saveButton');
  const uploadBtn = document.getElementById('uploadBtn');

  uploadBtn.onclick = () => { fileInput.click(); };

  fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      const uint8Arr = new Uint8Array(arrayBuffer);
      console.log('📷 选中图片，大小:', uint8Arr.length);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    document.getElementById("saveButton").style.display = "none";
  }

  const CHUNK_SIZE = 64 * 1024; // 64KB
  function safeSendPhoto(data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('⚠️ WebSocket 未连接，send photo 被忽略');
      return;
    }

    console.warn(`[${new Date().toLocaleString()}] 📤 开始发送图片，大小: ${data.length} bytes`);

    const totalChunks = Math.ceil(data.length / CHUNK_SIZE);
    const uid = Date.now();

    for (let i = 0; i < totalChunks; i++) {
      const chunk = data.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
      const message = {
        type: 'photo_chunk',
        uid,
        index: i,
        total: totalChunks,
        data: Array.from(chunk),
      };
      socket.send(JSON.stringify(message));
    }

    console.warn(`[${new Date().toLocaleString()}] ✅ 图片拆包发送完成，共 ${totalChunks} 块`);
  }

  // ============================
  // 页面初始化
  // ============================
  (async function init() {
    await configureDecoder();
    createSocket();
  })();

</script>
</body>
</html>
