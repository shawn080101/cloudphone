<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebCodecs H264 + PCM 播放器（可保存）</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton, #uploadBtn {
      position: fixed;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    #saveButton { top: 100px; left: 10px; }
    #uploadBtn {
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
  <canvas id="canvas"></canvas>
  <button id="saveButton" onclick="downloadStreams()">选择照片</button>
  <button id="uploadBtn">选择照片</button>
  <input type="file" id="fileInput" accept="image/*" style="display:none" />
  <div id="latencyDisplay">延时: -- ms | 解码: -- ms</div>

  <script>
  // =================== WebSocket 自动重连与发送 ===================
  let socket = null, reconnectTimer = null, connect = false, os = "";
  let latency = '--', pingStartTime = 0, pingInterval = null;

  // === 新增: 掉帧统计变量 ===
  let expectedFrames = 0, decodedFrames = 0, droppedFrames = 0;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=8ff9086396a4e48980c501213991d7e0');
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('✅ WebSocket 已连接');
      if (reconnectTimer) clearTimeout(reconnectTimer);
      document.getElementById('latencyDisplay').textContent = `✅ 已连接 | 延时: -- ms | 解码: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }

      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      console.warn(`[${new Date().toLocaleString()}] ❌ WebSocket 已断开，2秒后尝试重连`);
      document.getElementById('latencyDisplay').textContent = '❌ 连接断开，正在重连...';
      connect = false;
      if (pingInterval) { clearInterval(pingInterval); pingInterval = null; }
      if (!reconnectTimer) reconnectTimer = setTimeout(createSocket, 2000);
    };

    socket.onerror = e => console.warn('WebSocket 错误:', e);
    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) socket.send(data);
    else console.warn('⚠️ WebSocket 未连接，send 被忽略:', data);
  }

  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // =================== Canvas & WebCodecs 视频解码 ===================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let videoDecoder = null, frameQueue = [], MAX_FRAME_QUEUE = 10, decoding = false;
  let isStart = false, lastVideoPTS = 0, startTime = 0;

  // === 新增: 保存每个PTS的接收时间 ===
  const recvTimeMap = new Map();
  let lastDecodeCost = '--';

  function initDecoder() {
    videoDecoder = new VideoDecoder({
      output: frame => {
        const pts = frame.timestamp;
        const endTime = performance.now();
        if (recvTimeMap.has(pts)) {
          const cost = endTime - recvTimeMap.get(pts);
          lastDecodeCost = cost.toFixed(0); // 保存耗时(ms)
          recvTimeMap.delete(pts);
        }

        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
        frame.close();
        decodedFrames++;
      },
      error: e => console.error('VideoDecoder error:', e)
    });

    videoDecoder.configure({
      codec: 'avc1.42E01E',
      codedWidth: 720,
      codedHeight: 1280,
      optimizeForLatency: true,
      hardwareAcceleration: "prefer-hardware",
    });

    isStart = false;
  }
  initDecoder();

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (payload[i] === 0x00 && payload[i+1] === 0x00 && payload[i+2] === 0x00 && payload[i+3] === 0x01) {
        if ((payload[i+4] & 0x1F) === 5) return true;
      }
    }
    return false;
  }

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payloadWithPTS = frameQueue.shift();
    expectedFrames++;

    const ptsView = new DataView(payloadWithPTS.buffer, payloadWithPTS.byteOffset, 8);
    const ptsUs = Number(ptsView.getBigUint64(0));
    const nalu = payloadWithPTS.slice(8);
    const isKey = isIDR(nalu);

    if (!isKey && !isStart) return;

    decoding = true;

    try {
      if (isKey && !isStart) {
        isStart = true;
        lastVideoPTS = ptsUs / 1000;
        startTime = performance.now();
      }

      const targetTime = startTime + (ptsUs / 1000 - lastVideoPTS);
      let delay = targetTime - performance.now();

      if (delay < -2000) delay = 0; // 延迟超过2s → 立即解码

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: ptsUs,
        data: nalu
      });

      recvTimeMap.set(ptsUs, performance.now());

      if (delay > 0) {
        setTimeout(() => {
          videoDecoder.decode(chunk);
          decoding = false;
          setTimeout(decodeNextFrame, 0);
        }, delay);
      } else {
        videoDecoder.decode(chunk);
        decoding = false;
        setTimeout(decodeNextFrame, 0);
      }
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try { if (videoDecoder.state !== 'closed') videoDecoder.close(); } catch(e){console.warn(e);}
    initDecoder();
    console.log('✅ Decoder 重建成功，等待关键帧');
  }

  // =================== 音频播放 ===================
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000, channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        channelData[i] = int16Data[i * channelCount + ch] / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) nextAudioTime = now;
    if (nextAudioTime - now > MAX_DELAY) nextAudioTime = now;

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => source.disconnect();
  }

  // =================== Canvas 缩放适配 ===================
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    let displayWidth = window.innerWidth;
    let displayHeight = displayWidth / aspectRatio;

    if (displayHeight > window.innerHeight) {
      displayHeight = window.innerHeight;
      displayWidth = displayHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // =================== 鼠标 & 触摸事件 ===================
  let isDown = false, moveQueue = [], showPhoto = false, photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (clientX - rect.left) * (canvas.width / rect.width),
      y: (clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  function sendDown(x, y) { safeSend(JSON.stringify({ start: `${x},${y}` })); }
  function sendMove(x, y) { moveQueue.push({x,y}); }
  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));
    if (photoRegion) {
      const inside = x >= photoRegion.left && x <= photoRegion.right && y >= photoRegion.top && y <= photoRegion.bottom;
      if (inside) { showPhoto = false; photoRegion = null; uploadBtn.click(); }
    }
  }

  function flushMoveQueue() {
    if (moveQueue.length > 0) {
      const last = moveQueue[moveQueue.length - 1];
      safeSend(JSON.stringify({ swipe: `${last.x},${last.y}` }));
      moveQueue = [];
    }
    requestAnimationFrame(flushMoveQueue);
  }
  requestAnimationFrame(flushMoveQueue);

  canvas.addEventListener('mousedown', e => { isDown=true; const c=getCanvasCoords(e.clientX,e.clientY); sendDown(c.x,c.y); });
  canvas.addEventListener('mousemove', e => { if(!isDown) return; const c=getCanvasCoords(e.clientX,e.clientY); sendMove(c.x,c.y); });
  canvas.addEventListener('mouseup', e => { if(!isDown) return; isDown=false; const c=getCanvasCoords(e.clientX,e.clientY); sendUp(c.x,c.y); });

  canvas.addEventListener('touchstart', e => { e.preventDefault(); if(e.touches.length===0) return; isDown=true; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendDown(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!isDown) return; const t=getCanvasCoords(e.touches[0].clientX,e.touches[0].clientY); sendMove(t.x,t.y); }, {passive:false});
  canvas.addEventListener('touchend', e => { e.preventDefault(); if(!isDown) return; isDown=false; if(e.changedTouches.length===0) return; const t=getCanvasCoords(e.changedTouches[0].clientX,e.changedTouches[0].clientY); sendUp(t.x,t.y); }, {passive:false});

  // =================== WebSocket 消息处理 ===================
  function onMessageHandler(event) {
    const data = event.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd==='pong') { 
          latency = Math.round(performance.now()-pingStartTime); 
        }
      } catch(e){ console.warn('JSON 解析失败:', e); }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    switch(type){
      case 0x01:
        if(frameQueue.length>=MAX_FRAME_QUEUE){ 
          const idx=frameQueue.findIndex(buf=>!isIDR(buf));
          if (idx!==-1) {
            frameQueue.splice(idx,1);
            droppedFrames++;
          } else {
            frameQueue.shift();
            droppedFrames++;
          }
        }
        frameQueue.push(payload);
        decodeNextFrame();
        break;
      case 0x02: playPCM(payload); break;
      case 0x03: console.log("键盘指令 show =",payload[0]); break;
      case 0x04: 
        if(payload.length>=8){
          const view=new DataView(payload.buffer,payload.byteOffset,payload.byteLength);
          photoRegion={ left:view.getInt16(0), top:view.getInt16(2), right:view.getInt16(4), bottom:view.getInt16(6) };
          showPhoto=true;
        } else { photoRegion=null; }
        break;
      case 0x05: console.log("ready", payload[0]); break;
    }
  }

  // =================== 图片上传 ===================
  const fileInput=document.getElementById('fileInput');
  const saveButton=document.getElementById('saveButton');
  const uploadBtn=document.getElementById('uploadBtn');

  uploadBtn.onclick=()=>fileInput.click();

  fileInput.onchange=()=>{
    const file=fileInput.files[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=()=>{
      const uint8Arr=new Uint8Array(reader.result);
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    safeSend(JSON.stringify({ bit_rate: `600000` }));
  }

  const CHUNK_SIZE=64*1024;
  function safeSendPhoto(data){
    if(!socket || socket.readyState!==WebSocket.OPEN) return;
    const totalChunks=Math.ceil(data.length/CHUNK_SIZE);
    const uid=Date.now();

    for(let i=0;i<totalChunks;i++){
      const chunk=data.slice(i*CHUNK_SIZE,(i+1)*CHUNK_SIZE);
      const message={ type:'photo_chunk', uid, index:i, total:totalChunks, data:Array.from(chunk) };
      socket.send(JSON.stringify(message));
    }
  }

  // =================== 统一性能监控 ===================
  function monitorPerformance() {
    const totalQueueBytes = frameQueue.reduce((sum, buf) => sum + buf.byteLength, 0);
    const dropRate = expectedFrames > 0 ? (droppedFrames / expectedFrames) * 100 : 0;
    const decodeTime = parseFloat(lastDecodeCost) || 0;
    const currentLatency = latency !== '--' ? latency : 0;

    let status = 'ok';
    if (dropRate > 10 || currentLatency > 150 || decodeTime > 40 || totalQueueBytes > 512*1024) {
      status = 'warn';
    }

    if (socket && socket.readyState === WebSocket.OPEN) {
      safeSend(JSON.stringify({
        cmd: 'performance',
        dropRate: dropRate.toFixed(2),
        latency: currentLatency,
        decodeTime: decodeTime.toFixed(0),
        queueBytes: totalQueueBytes,
        status: status
      }));
    }

    document.getElementById('latencyDisplay').textContent =
      `延时: ${currentLatency} ms | 解码: ${decodeTime.toFixed(0)} ms | 掉帧率: ${dropRate.toFixed(1)}% | 队列: ${(totalQueueBytes/1024).toFixed(0)} KB`;

    expectedFrames = decodedFrames = droppedFrames = 0;
  }
  setInterval(monitorPerformance, 200);

  // =================== 页面初始化 ===================
  createSocket();
  </script>
</body>
</html>