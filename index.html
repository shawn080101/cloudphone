<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebCodecs H264 + PCM Êí≠ÊîæÂô®ÔºàÂèØ‰øùÂ≠òÔºâ</title>
  <style>
    body { background: #000; margin: 0; overflow: hidden; }
    canvas {
      display: block;
      margin: auto;
      position: absolute;
      top: 0; bottom: 0; left: 0; right: 0;
    }
    #saveButton {
      position: fixed;
      top: 100px;
      left: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #uploadBtn {
      position: fixed;
      top: 50%;
      left: 10%;
      transform: translate(-50%, -50%);
      z-index: 999;
      padding: 6px 12px;
      background: #09f;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }
    #latencyDisplay {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 999;
      padding: 6px 12px;
      background: rgba(0,0,0,0.6);
      color: #0f0;
      font-size: 14px;
      font-family: monospace;
      border-radius: 6px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
</head>
<body>
<canvas id="canvas"></canvas>
<button id="saveButton" onclick="downloadStreams()">ÈÄâÊã©ÁÖßÁâá</button>
<button id="uploadBtn">ÈÄâÊã©ÁÖßÁâá</button>
<input type="file" id="fileInput" accept="image/*" style="display:none" />
<div id="latencyDisplay">‚è± Âª∂Êó∂: -- ms</div>

<script>
  // --- WebSocket Ëá™Âä®ÈáçËøûÂíåÂÆâÂÖ®ÂèëÈÄÅÂ∞ÅË£Ö ---
  let socket = null;
  let reconnectTimer = null;
  let connect = false;
  let os = "";
  let latency = '--';
  let pingStartTime = 0;
  let pingInterval = null;

  function createSocket() {
    socket = new WebSocket('wss://cn2.androidcloudtest.com/scws/?token=287467d5dc90550e9431a7226f03024d'); //wss://cn2.androidcloudtest.com/scws ws://192.168.190.4:3000
    socket.binaryType = 'arraybuffer';

    socket.onopen = () => {
      console.log('‚úÖ WebSocket Â∑≤ËøûÊé•');
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      /*console.log('resend', resend);
      if (resend) {
        console.log('ÈáçÂèëÂõæÁâá');
        safeSendPhoto(lastImageData);
        resend = false;
      }*/
      document.getElementById('latencyDisplay').textContent = `‚úÖ Â∑≤ËøûÊé• | Âª∂Êó∂: -- ms`;

      if (!connect) {
        connect = true;
        os = "ios";
        safeSend(JSON.stringify({ wm_size: `720x1280` }));
        safeSend(JSON.stringify({ dpi: `320` }));
        safeSend(JSON.stringify({ os: `ios` }));
        //safeSend(JSON.stringify({ switch_activity: `com.android.settings/.Settings` })); //com.s15af5x.all2/com.yyds.sportnew.StartActivity com.android.settings/.Settings
        //safeSend(JSON.stringify({ scheme: `tml0cj://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //ÂºÄ‰∫ë ÂæàÊÖ¢ schemeÂäüËÉΩok
        //safeSend(JSON.stringify({ scheme: `t06fut://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //Áà±Ê∏∏Êàè schemeÂäüËÉΩok
        //safeSend(JSON.stringify({ scheme: `tqnc02://com.s15af5x.fao2f4o5?data=bobCloud&name=shawn1&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //‰πêÈ±º ÂæàÊÖ¢ schemeÂäüËÉΩok
        //safeSend(JSON.stringify({ scheme: `tg7ooa://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //Âçé‰Ωì‰ºö ÂæàÊÖ¢ schemeÂäüËÉΩok
        safeSend(JSON.stringify({ scheme: `tcph0g://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //Á±≥ÂÖ∞ ÂæàÊÖ¢ schemeÂäüËÉΩok
        //safeSend(JSON.stringify({ scheme: `tap6xh://com.bob.games?data=bobCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //‰πùÊ∏∏ ÂæàÊÖ¢ schemeÂäüËÉΩok
        //safeSend(JSON.stringify({ scheme: ` od://com.od.games?data=odCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //od Èó™ÈÄÄ
        //safeSend(JSON.stringify({ scheme: ` xk://com.xk.games?data=xkCloud&name=shawn22222&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //ÊòüÁ©∫ Èó™ÈÄÄ
        //safeSend(JSON.stringify({ scheme: `tc0hdu://com.bob.live?data=bobCloud&name=shawn1&password=KnlGxV48eTyjZmg%2FmTfE9Q%3D%3D&token=` })); //MK ÂæàÊÖ¢ ‰∏çÂØπ
        //safeSend(JSON.stringify({ scheme: `tqnc02://com.s15af5x.fao2f4o5?data=bobCloud&name=final006&password=7Kxg5sfoqHX4GT6CLjFK1g%3D%3D&token=` }));
        safeSend(JSON.stringify({ cp: `shawnn` }));
        safeSend(JSON.stringify({ connect: `1` }));
        safeSend(JSON.stringify({ command: `wm size` }));
      }
      if (pingInterval) {
        clearInterval(pingInterval);
      }
      pingInterval = setInterval(sendPing, 1000);
    };

    socket.onclose = () => {
      //console.warn(`[${new Date().toLocaleString()}] 222`);
      /*if (Date.now() - lastSendTime < 100) {
        resend = true;
        console.log(`[${new Date().toLocaleString()}] ‚ùå WebSocket Â∑≤Êñ≠ÂºÄÔºå2ÁßíÂêéÂ∞ùËØïÈáçËøû, 100msÂÜÖÔºåÈáçÂèëÁÖßÁâá`);
      } else {
        console.warn(`[${new Date().toLocaleString()}] ‚ùå WebSocket Â∑≤Êñ≠ÂºÄÔºå2ÁßíÂêéÂ∞ùËØïÈáçËøû`);
      }*/
      console.warn(`[${new Date().toLocaleString()}] ‚ùå WebSocket Â∑≤Êñ≠ÂºÄÔºå2ÁßíÂêéÂ∞ùËØïÈáçËøû`);
      document.getElementById('latencyDisplay').textContent = '‚ùå ËøûÊé•Êñ≠ÂºÄÔºåÊ≠£Âú®ÈáçËøû...';
      connect = false;
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
      if (!reconnectTimer) {
        reconnectTimer = setTimeout(() => {
          createSocket();
        }, 2000);
      }
    };

    socket.onerror = (e) => {
      console.warn('WebSocket ÈîôËØØ:', e);
    };

    socket.onmessage = onMessageHandler;
  }

  function safeSend(data) {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(data);
    } else {
      console.warn('‚ö†Ô∏è WebSocket Êú™ËøûÊé•Ôºåsend Ë¢´ÂøΩÁï•:', data);
    }
  }

  // --- Canvas Âíå WebCodecs ËßÜÈ¢ëËß£Á†ÅÁõ∏ÂÖ≥ ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 720;
  canvas.height = 1280;

  let decodedFrameCount = 0;
  let lastFpsTime = performance.now();
  let currentFps = 0;

  let videoDecoder = new VideoDecoder({
    output: frame => {
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
      frame.close();
      decodedFrameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        currentFps = decodedFrameCount;
        decodedFrameCount = 0;
        lastFpsTime = now;
        document.getElementById('latencyDisplay').textContent = `‚è± Âª∂Êó∂: ${latency} ms | üéû FPS: ${currentFps}`;
      }
    },
    error: e => console.error('VideoDecoder error:', e),
  });

  videoDecoder.configure({
    codec: 'avc1.4d401f',
    codedWidth: 720,
    codedHeight: 1280,
    optimizeForLatency: true,
    hardwareAcceleration: "prefer-hardware",
  });

  // --- Èü≥È¢ëÊí≠Êîæ ---
  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sampleRate = 8000;
  const channelCount = 1;
  let nextAudioTime = 0;

  function playPCM(data) {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const int16Data = new Int16Array(data.buffer || data);
    const frameCount = int16Data.length / channelCount;
    const audioBuffer = audioCtx.createBuffer(channelCount, frameCount, sampleRate);

    for (let ch = 0; ch < channelCount; ch++) {
      const channelData = audioBuffer.getChannelData(ch);
      for (let i = 0; i < frameCount; i++) {
        const sample = int16Data[i * channelCount + ch];
        channelData[i] = sample / 32768;
      }
    }

    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    const MAX_DELAY = 0.05;

    if (nextAudioTime === 0 || nextAudioTime < now) {
      nextAudioTime = now;
    }
    if (nextAudioTime - now > MAX_DELAY) {
      nextAudioTime = now;
    }

    source.start(nextAudioTime);
    nextAudioTime += audioBuffer.duration;
    source.onended = () => {
      source.disconnect();
    };
  }

  // --- ÁîªÂ∏ÉÁº©ÊîæÈÄÇÈÖç ---
  function resizeCanvas() {
    const aspectRatio = 720 / 1280;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let displayWidth = windowWidth;
    let displayHeight = windowWidth / aspectRatio;

    if (displayHeight > windowHeight) {
      displayHeight = windowHeight;
      displayWidth = windowHeight * aspectRatio;
    }

    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // --- Ëß¶Êë∏ÂíåÈº†Ê†á‰∫ã‰ª∂ ---
  let isDown = false;
  let throttleTimer = null;
  let showPhoto = false;
  let photoRegion = null;

  function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function sendDown(x, y) {
    safeSend(JSON.stringify({ start: `${x},${y}` }));
  }

  function sendMove(x, y) {
    safeSend(JSON.stringify({ swipe: `${x},${y}` }));
  }

  function sendUp(x, y) {
    safeSend(JSON.stringify({ end: `${x},${y}` }));

    if (photoRegion) {
      const { left, top, right, bottom } = photoRegion;
      const inside = x >= left && x <= right && y >= top && y <= bottom;
      if (inside) {
        console.log('‚úÖ ÁÇπÂáªÂú®ÁÖßÁâáÂå∫ÂüüÂÜÖ:', x, y);
        showPhoto = false;
        photoRegion = null;
        uploadBtn.click();
      } else {
        console.log('‚ùå ÁÇπÂáªÂú®Âå∫ÂüüÂ§ñ:', x, y);
      }
    }
  }

  canvas.addEventListener('mousedown', e => {
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendDown(x, y);
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    e.preventDefault();
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('mouseup', e => {
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    const { x, y } = getCanvasCoords(e.clientX, e.clientY);
    sendUp(x, y);
  });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (e.touches.length === 0) return;
    isDown = true;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendDown(x, y);
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isDown || throttleTimer) return;
    throttleTimer = setTimeout(() => { throttleTimer = null; }, 16);
    const touch = e.touches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendMove(x, y);
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (!isDown) return;
    isDown = false;
    throttleTimer = null;
    if (e.changedTouches.length === 0) return;
    const touch = e.changedTouches[0];
    const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
    sendUp(x, y);
  }, { passive: false });

  // --- Èü≥ËßÜÈ¢ëÁºìÂ≠òÂíåËß£Á†Å ---
  const frameQueue = [];
  const MAX_FRAME_QUEUE = 10;
  let decoding = false;
  let isStart = false;
  let lastVideoTimestamp = 0;
  const frameDurationUs = 1000000 / 60;

  function decodeNextFrame() {
    if (decoding || frameQueue.length === 0 || videoDecoder.decodeQueueSize > 3) return;

    const payload = frameQueue.shift();
    const isKey = isIDR(payload);

    if (!isKey && !isStart) return;

    decoding = true;
    try {
      if (isKey) {
        isStart = true;
        lastVideoTimestamp = performance.now() * 1000;
      } else {
        lastVideoTimestamp += frameDurationUs;
      }

      const chunk = new EncodedVideoChunk({
        type: isKey ? 'key' : 'delta',
        timestamp: lastVideoTimestamp,
        data: payload
      });

      videoDecoder.decode(chunk);
    } catch (err) {
      console.error('Video decode error:', err);
      resetDecoder();
    } finally {
      decoding = false;
      setTimeout(decodeNextFrame, 0);
    }
  }

  function resetDecoder() {
    try {
      if (videoDecoder.state !== 'closed') videoDecoder.close();
    } catch (e) {
      console.warn('ÂÖ≥Èó≠ decoder Â§±Ë¥•:', e);
    }

    try {
      videoDecoder = new VideoDecoder({
        output: frame => {
          ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
          frame.close();
          decodedFrameCount++;
          const now = performance.now();
          if (now - lastFpsTime >= 1000) {
            currentFps = decodedFrameCount;
            decodedFrameCount = 0;
            lastFpsTime = now;
            document.getElementById('latencyDisplay').textContent = `‚è± Âª∂Êó∂: ${latency} ms | üéû FPS: ${currentFps}`;
          }
        },
        error: e => console.error('VideoDecoder error:', e),
      });

      videoDecoder.configure({
        codec: 'avc1.4d401f',
        optimizeForLatency: true,
        hardwareAcceleration: "prefer-hardware",
        codedWidth: 720,
        codedHeight: 1280,
      });

      isStart = false;
      console.log('‚úÖ Decoder ÈáçÂª∫ÊàêÂäüÔºåÁ≠âÂæÖÂÖ≥ÈîÆÂ∏ß');
    } catch (e) {
      console.error('‚ùå DecoderÊÅ¢Â§çÂ§±Ë¥•:', e);
    }
  }

  function isIDR(payload) {
    for (let i = 0; i < payload.length - 4; i++) {
      if (
        payload[i] === 0x00 &&
        payload[i+1] === 0x00 &&
        payload[i+2] === 0x00 &&
        payload[i+3] === 0x01
      ) {
        const nalType = payload[i+4] & 0x1F;
        if (nalType === 5) { // IDRÂ∏ß
          return true;
        }
      }
    }
    return false;
  }

  // --- WebSocket Ê∂àÊÅØÂ§ÑÁêÜ ---
  function onMessageHandler(event) {
    const data = event.data;
    //console.log("Êî∂Âà∞Ê∂àÊÅØ:", event.data);
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        if (msg.cmd === 'pong') {
          const pingEndTime = performance.now();
          latency = Math.round(pingEndTime - pingStartTime);
          document.getElementById('latencyDisplay').textContent = `‚è± Âª∂Êó∂: ${latency} ms | üéû FPS: ${currentFps}`;
        }
      } catch (e) {
        console.warn('JSON Ëß£ÊûêÂ§±Ë¥•:', e);
      }
      return;
    }

    const buffer = new Uint8Array(data);
    const type = buffer[0];
    const payload = buffer.slice(1);

    if (type === 0x01) { // ËßÜÈ¢ë
      if (frameQueue.length >= MAX_FRAME_QUEUE) {
        const index = frameQueue.findIndex(buf => !isIDR(buf));
        if (index !== -1) {
          frameQueue.splice(index, 1);
        } else {
          frameQueue.shift();
        }
        console.warn('‚ö†Ô∏è ‰∏¢Â∏ß‰ª•ÊéßÂà∂Âª∂Ëøü');
      }
      frameQueue.push(payload);
      decodeNextFrame();
    } else if (type === 0x02) { // Èü≥È¢ë
      try {
        playPCM(payload);
      } catch (err) {
        console.error('PCM Êí≠ÊîæÂá∫Èîô:', err);
      }
    } else if (type === 0x03) { // ÈîÆÁõò
      const show = payload[0];
      console.log("ÈîÆÁõòÊåá‰ª§ show =", show);
      if (os === "android") {
        if (show === 1) {
          //document.getElementById('fakeInput').focus();
        } else {
          //document.getElementById('fakeInput').blur();
        }
      }
    } else if (type === 0x04) { // ÁÖßÁâáÂå∫Âüü
      if (payload.length >= 8) {
        const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
        const left = view.getInt16(0);
        const top = view.getInt16(2);
        const right = view.getInt16(4);
        const bottom = view.getInt16(6);
        console.log("üì∏ ÁÖßÁâáÂå∫ÂüüÂùêÊ†á:", left, top, right, bottom);
        photoRegion = { left, top, right, bottom };
        showPhoto = true;
      } else {
        photoRegion = null;
        console.warn('‚ö†Ô∏è Êî∂Âà∞0x04Êï∞ÊçÆÈïøÂ∫¶‰∏çË∂≥');
      }
    } else if (type === 0x05) { // ready
      console.log("ready")
      if (payload[0] === 1) {
        console.log("payload[0]:", payload[0])
      }
      
    }
  }

  // --- ÂèëÈÄÅ ping ÊµãÂª∂Êó∂ ---
  function sendPing() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      pingStartTime = performance.now();
      safeSend(JSON.stringify({ cmd: 'ping' }));
    }
  }

  // --- ÈÄâÊã©ÁÖßÁâá‰∏ä‰º†Áõ∏ÂÖ≥ ---
  const fileInput = document.getElementById('fileInput');
  const saveButton = document.getElementById('saveButton');
  const uploadBtn = document.getElementById('uploadBtn');
  let lastImageData = null; // ÁºìÂ≠òÂõæÁâáÊï∞ÊçÆ
  //let lastSendTime = 0;
  //let resend = false;

  uploadBtn.onclick = () => {
    fileInput.click();
  };

  fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      const arrayBuffer = reader.result;
      const uint8Arr = new Uint8Array(arrayBuffer);
      console.log('üì∑ ÈÄâ‰∏≠ÂõæÁâáÔºåÂ§ßÂ∞è:', uint8Arr.length);
      //lastImageData = uint8Arr; // ÁºìÂ≠ò‰∏ãÊù•
      safeSendPhoto(uint8Arr);
    };
    reader.readAsArrayBuffer(file);
  };

  function downloadStreams() {
    // ËøôÈáåÂ¶ÇÊûú‰Ω†ÊúâÁºìÂ≠òËßÜÈ¢ëÈü≥È¢ëÊï∞ÊçÆÔºåÂèØ‰ª•ÊâìÂåÖ‰∏ãËΩΩ
    document.getElementById("saveButton").style.display = "none";
  }

  const CHUNK_SIZE = 64 * 1024; // 64KB
  function safeSendPhoto(data) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      console.warn('‚ö†Ô∏è WebSocket Êú™ËøûÊé•Ôºåsend photo Ë¢´ÂøΩÁï•');
      return;
    }

    console.warn(`[${new Date().toLocaleString()}] üì§ ÂºÄÂßãÂèëÈÄÅÂõæÁâáÔºåÂ§ßÂ∞è: ${data.length} bytes`);

    const totalChunks = Math.ceil(data.length / CHUNK_SIZE);
    const uid = Date.now(); // ÊØèÂº†Âõæ‰∏Ä‰∏™ÂîØ‰∏Ä ID

    for (let i = 0; i < totalChunks; i++) {
      const chunk = data.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);

      const message = {
        type: 'photo_chunk',
        uid,              // ÂõæÂÉèÂîØ‰∏ÄÊ†áËØÜ
        index: i,         // ÂΩìÂâçÂùóÂ∫èÂè∑
        total: totalChunks, // ÊÄªÂùóÊï∞
        data: Array.from(chunk), // ËΩ¨ÊàêÂèØÂ∫èÂàóÂåñÊ†ºÂºè
      };

      socket.send(JSON.stringify(message));
    }

    lastSendTime = Date.now();
    console.warn(`[${new Date().toLocaleString()}] ‚úÖ ÂõæÁâáÊãÜÂåÖÂèëÈÄÅÂÆåÊàêÔºåÂÖ± ${totalChunks} Âùó`);
  }

  // --- È°µÈù¢ÂàùÂßãÂåñ ---
  createSocket();

</script>
</body>
</html>
